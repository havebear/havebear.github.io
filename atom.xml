<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Have Bear</title>
  
  <subtitle>码农、骑行、狗，和一只熊</subtitle>
  <link href="http://havebear.com/atom.xml" rel="self"/>
  
  <link href="http://havebear.com/"/>
  <updated>2025-07-18T06:11:13.169Z</updated>
  <id>http://havebear.com/</id>
  
  <author>
    <name>havebear</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025年07月18日随记</title>
    <link href="http://havebear.com/2025/07/18/%E9%9A%8F%E8%AE%B0/2025%E5%B9%B407%E6%9C%8818%E6%97%A5%E9%9A%8F%E8%AE%B0/"/>
    <id>http://havebear.com/2025/07/18/%E9%9A%8F%E8%AE%B0/2025%E5%B9%B407%E6%9C%8818%E6%97%A5%E9%9A%8F%E8%AE%B0/</id>
    <published>2025-07-18T06:04:45.706Z</published>
    <updated>2025-07-18T06:11:13.169Z</updated>
    
    <content type="html"><![CDATA[<p>时隔很久，重新拾起博客，感叹自己生活、工作和想法的巨变，总要留下些什么，今年是 ai agent 大爆发的一年，去年还见大家面对 ai 的困惑，现今包括我已经在方方面面的使用 ai，关于职业的未来，先把现在做好，积极拥抱新事物，不断成长和学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时隔很久，重新拾起博客，感叹自己生活、工作和想法的巨变，总要留下些什么，今年是 ai agent 大爆发的一年，去年还见大家面对 ai 的困惑，现今包括我已经在方方面面的使用 ai，关于职业的未来，先把现在做好，积极拥抱新事物，不断成长和学习。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="随记" scheme="http://havebear.com/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>输入URL到渲染全面梳理中-页面渲染篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.133Z</published>
    <updated>2025-07-18T06:03:17.133Z</updated>
    
    <content type="html"><![CDATA[<p>接上文，上文我们讲了网络通信的部分，详细请看 「一道面试题」输入URL到渲染全面梳理上-网络通信篇 ，那么该说说页面渲染的流程了，也就是当输入一个URL拿到了页面后，浏览器怎么解析，怎么呈现</p><span id="more"></span><p>首先要了解这块内容，需要对下面这些知识点有一个简单认知</p><p>线程/进程概念及区别<br>多线程/多进程概念<br>浏览器的主要进程<br>浏览器为什么是多进程<br>渲染进程Renderer的主要线程</p><p>GUI渲染线程<br>JS引擎线程<br>事件触发线程<br>定时触发线程<br>异步http请求线程</p><p>渲染进程的各个线程之间关系及配合</p><p>进程与线程<br>什么是进程<br>我们都知道，CPU是计算机的核心，承担所有的计算任务<br>官方说法，进程是CPU资源分配的最小单位<br>字面意思就是进行中的程序，我将它理解为一个可以独立运行且拥有自己的资源空间的任务程序<br>进程包括运行中的程序和程序所使用到的内存和系统资源<br>CPU 可以有很多进程，我们的电脑每打开一个软件就会产生一个或多个 进程 ，为什么电脑运行的软件多就会卡，是因为 CPU 给每个 进程 分配资源空间，但是一个 CPU 一共就那么多资源，分出去越多，越卡，每个进程之间是相互独立的， CPU 在运行一个 进程 时，其他的进程处于非运行状态，CPU 使用 时间片轮转调度算法 来实现同时运行多个进程<br>什么是线程<br>线程 是 CPU 调度的最小单位<br>线程 是建立在 进程 的基础上的一次程序运行单位，通俗点解释 线程 就是程序中的一个执行流，一个 进程 可以有多个 线程<br>一个 进程 中只有一个执行流称作 单线程 ，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行<br>一个 进程 中有多个执行流称作 多线程，即在一个程序中可以同时运行多个不同的 线程 来执行不同的任务， 也就是说允许单个程序创建多个并行执行的 线程 来完成各自的任务<br>进程和线程的区别<br>进程是操作系统分配资源的最小单位，线程是程序执行的最小单位<br>一个 进程 由一个或多个 线程 组成，线程 可以理解为是一个进程中代码的不同执行路线<br>进程 之间相互独立，但同一进程下的各个 线程 间共享程序的内存空间 (包括代码段、数据集、堆等) 及一些进程级的资源 (如打开文件和信号)<br>调度和切换：线程上下文切换比进程上下文切换要快得多<br>多进程和多线程<br>多进程： 多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰<br>多线程： 多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务<br>JS为什么是单线程<br>JS的单线程，与它的用途有关，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题<br>比如，假定 JavaScript 同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>还有人说 js 还有 Worker 线程，对的，为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许 JavaScript 脚本创建多个线程，但是子线程是完 全受主线程控制的，而且不得操作DOM<br>所以，这个标准并没有改变JavaScript是单线程的本质<br>了解了进程和线程之后，接下来看看浏览器解析，浏览器之间也是有些许差距的，不过大致是差不多的，下文我们皆用市场占有比例最大的Chrome为例<br>浏览器相关<br>浏览器是多进程的<br>作为前端，免不了和浏览器打交道，浏览器是多进程的，拿 Chrome 来说，我们每打开一个Tab页就会产生一个进程，我们使用 Chrome 打开很多标签页不关，电脑会越来越卡，不说其他，首先就很耗CPU<br>浏览器包含哪些进程</p><p>Browser进程</p><p>浏览器的主进程(负责协调、主控)，该进程只有一个<br>负责浏览器界面显示，与用户交互。如前进，后退等<br>负责各个页面的管理，创建和销毁其他进程<br>将渲染(Renderer)进程得到的内存中的Bitmap(位图)，绘制到用户界面上<br>网络资源的管理，下载等</p><p>第三方插件进程</p><p>每种类型的插件对应一个进程，当使用该插件时才创建</p><p>GPU进程</p><p>该进程也只有一个，用于3D/动画绘制等等</p><p>渲染进程(重)</p><p>即通常所说的浏览器内核(Renderer进程，内部是多线程)<br>每个Tab页面都有一个渲染进程，互不影响<br>主要作用为页面渲染，脚本执行，事件处理等</p><p>为什么浏览器要多进程<br>我们假设浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差<br>同理如果插件崩溃了也会影响整个浏览器<br>当然多进程还有其它的诸多优势，不过多阐述<br>浏览器进程有很多，每个进程又有很多线程，都会占用内存<br>这也意味着内存等资源消耗会很大，有点拿空间换时间的意思<br>到此可不只是为了让我们理解为何Chrome运行时间长了电脑会卡，哈哈，第一个重点来了<br>简述渲染进程Renderer(重)<br>页面的渲染，JS的执行，事件的循环，都在渲染进程内执行，所以我们要重点了解渲染进程<br>渲染进程是多线程的，我们来看渲染进程的一些常用较为主要的线程<br>渲染进程Renderer的主要线程<br>GUI渲染线程</p><p>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等</p><p>解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree<br>解析css，生成CSSOM(CSS规则树)<br>把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)</p><p>当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)<br>当我们修改元素的尺寸，页面就会回流(Reflow)<br>当页面需要Repaing和Reflow时GUI线程执行，绘制页面<br>回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免Reflow和Repaint<br>GUI渲染线程与JS引擎线程是互斥的</p><p>当JS引擎执行时GUI线程会被挂起(相当于被冻结了)<br>GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</p><p>JS引擎线程</p><p>JS引擎线程就是JS内核，负责处理Javascript脚本程序(例如V8引擎)<br>JS引擎线程负责解析Javascript脚本，运行代码<br>JS引擎一直等待着任务队列中任务的到来，然后加以处理</p><p>浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的<br>一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序</p><p>GUI渲染线程与JS引擎线程是互斥的，js引擎线程会阻塞GUI渲染线程</p><p>就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)<br>例如浏览器渲染的时候遇到script标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。所以如果js执行时间太长就会造成页面卡顿的情况</p><p>事件触发线程</p><p>属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列(task queue)<br>当js执行碰到事件绑定和一些异步操作(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理。<br>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理<br>因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理</p><p>定时触发器线程</p><p>setInterval 与 setTimeout 所在线程<br>浏览器定时计数器并不是由JavaScript引擎计数的 (因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)<br>通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程<br>W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</p><p>异步http请求线程</p><p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行<br>简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应 (准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行</p><p>了解了上面这些基础后，接下来我们开始进入今天的正题，输入URL拿到资源之后，如何渲染，又经历了那些过程？<br>渲染过程<br>Webkit渲染流程图<br>我们都知道，浏览器之间的渲染流程是有些细微差别的，我们这里介绍的一些知识点是基于Chrome的，也就是Webkit，毕竟它是主流，先来看一下Webkit的渲染流程图</p><p>大家如果第一次看到这张图，可能会有点迷茫，不知从哪看起，别急，先大致过一眼，我们下面会慢慢介绍，一步步的分析，如果大家完整的阅读完此文，不妨回过头来再看一遍这张图，会清晰很多<br>解析HTML构建DOM树<br>浏览器渲染，那么浏览器肯定就拿到页面内容了，肯定要先解析HTML的<br>话不多说，我们直接来看HTML解析的图 ( 网图侵删 )</p><p>如果是第一次看到这张图可能看不懂，没关系，慢慢道来<br>先来看图中解析DOM的这几个大过程<br>Bytes(字节) -&gt; Characters(字符) -&gt; Tokens(词) -&gt; Nodes(节点) -&gt; DOM(DOM树)<br>复制代码首先，发起请求拿到页面 HTML 内容，这个内容它是0/1这样的原始 字节流<br>接着，浏览器拿到这些 HTML 的原始字节，根据文件的指定编码 (例如 UTF-8) 将它们转换成各个 字符<br>现在字节流变成了 字符流 ，也就是一大串字符串<br>为了把 字符流 解析成正确的 DOM 结构，浏览器还要继续努力<br>接着进行 词法解析 ，把字符流初步解析成我们可理解的 词，学名叫 token<br>嗯？什么是词 (Token)？<br>词 是编译原理中的最小单元，如标签开始、属性、标签结束、注释、CDATA节点<br>Token 会标识出当前 Token 的种类，有点绕，怎么说方便理解呢，举个例子</p><div class="haha">haha</div>复制代码如上，这是一个标签它有一个class属性 (废话)，但是浏览器拿到的只是字符串，它不知道这都是什么标签有啥属性要做什么，那么得给它一点一点拆开读，就是词法解析，怎么解析，就像下面这样1. <div                    # 哦，看到了<div，这是一个div标签的开始2. class="haha" # 这是一个class属性3. >                        # 哦，到这儿是一个完整的div开始标签4. haha                    # 嗯，这是一个文本5. </div>                # 奥，看到了</div>，整个div标签结束了复制代码词法解析 是编译原理中的概念，上面是极度简化版本 (防大佬死磕)，只是为了方便大家理解现在理解了吗，Tokens 这个阶段中会标识出当前 Token 是 开始标签 或是 结束标签 亦或是 文本 等信息那么我们收回思路，接着上面的步骤，经历 词法解析 我们把字符流解析成了 词 (Token)接着在每个 Token 被生成后，会立刻消耗这个 Token 创建出节点对象，就是 节点 (Nodes) 阶段把开始结束标签配对、属性赋值好、父子关系这些都连接好了，最终就构成了 DOM 树后面这两小步也可称为 语法解析 ，到此 DOM Tree 就解析完了另外多嘴一句，DOM树(DOM Tree) | 文档对象模型 ，这些东西说的都是 DOM树解析CSS构建CSSOM树有 HTML 解析，那肯定有 CSS 解析，比如我们构建 DOM 的时候遇到了 link 标记，该标记引用一个外部 CSS 样式表，那么浏览器会认为它需要这个外部样式资源，就会立即发出对该资源的请求，并返回样式内容，也是字节流与处理 HTML 时一样，将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西，基本步骤重复 HTML 过程，不过是构建 CSS 而不是 HTML<p>CSS 字节转换成字符，接着词法解析与法解析，最后构成 CSS对象模型(CSSOM) 的树结构<br>我们都知道，节点样式是可以继承的，所以在构建的过程中浏览器得递归 DOM 树来确定元素到底是什么样式，为了 CSSOM 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 DOM 已经构建完了，也得等 CSSOM，然后才能进入下一个阶段<br>所以 CSS 的加载速度与构建 CSSOM 的速度会影响首屏渲染速度，这就是我们常说的 CSS 资源的加载会阻塞渲染<br>怎么优化？DOM树要小，CSS尽量用 id 和 class 少直接用标签😄<br>解析JavaScript脚本<br>这个解析 JS 的步骤是不固定的，因为在构建DOM 树的过程中，当 HTML 解析器遇到一个 script 标记时，即遇到了js，立即阻塞DOM树的构建，就会将控制权移交给 JavaScript 引擎，等到 JavaScript 引擎运行完毕，浏览器才会从中断的地方恢复DOM树的构建<br>为什么上面也说了，JS会对DOM节点进行操作，浏览器无法预测未来的DOM节点的具体内容，为了防止无效操作，节省资源，只能阻塞DOM树的构建<br>例如，若不阻塞DOM树的构建，若 JS 删除了某个DOM节点A，那么浏览器为构建此节点A花费的资源就是无效的<br>若在 HTML 头部加载 JS 文件，由于 JS 阻塞，会推迟页面的首绘，所以为了加快页面渲染，一般将 JS 文件放到HTML 底部进行加载，或是对 JS 文件执行 async 或 defer 加载</p><p>async 是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 onload 前，但不确定在 DOMContentLoaded 事件的前或后<br>defer 是延迟执行，在浏览器看起来的效果像是将脚本放在了 body 后面一样（虽然按规范应该是在 DOMContentLoaded 事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</p><p>构建渲染树/呈现树(Render Tree)<br>渲染树 ( Render Tree ) 由 DOM树、CSSOM树 合并而成，但并不是必须等 DOM树 及 CSSOM树 加载完成后才开始合并构建 渲染树，三者的构建并无先后条件，也并非完全独立，而是会有交叉，并行构建，因此会形成一边加载，一边解析，一边渲染的工作现象<br>CSSOM 树和 DOM 树 合并成渲染树，渲染树 只包含渲染网页所需的节点，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上</p><p>如上图 ( 网图侵删 ) ，为了构建渲染树，我们看看浏览器都做了什么</p><p>浏览器首先会从DOM树的根节点开始遍历每个可见节点</p><p>例如脚本标记、元标记等有些节点不可见，因为它们不会体现在渲染输出中，所以会被忽略<br>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如上图的其中一个 span 标签有 display: none 属性，也会被忽略</p><p>对于每个可见节点，找到其对应的的 CSSOM 规则并应用它们<br>输出可见节点，连同其内容和计算的样式</p><p>布局(Layout)<br>渲染树 同时包含了屏幕上的所有可见内容及其样式信息，有了渲染树，再接着就要进入布局 ( layout ) 阶段了，到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们还没有计算它们在设备 视口 内的确切位置和大小，这就是 布局 ( Layout ) 阶段，也称为 自动重排 或 回流 ( Reflow )<br>此阶段一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树<br>简单举个例子，我们看下面这段代码<br><!DOCTYPE html></p><html>  <head>    <meta name="viewport" content="width=device-width,initial-scale=1">    <title>hahaha</title>  </head>  <body>    <div style="width: 50%">      <div style="width: 50%">Hello world</div>    </div>  </body></html>复制代码上面代码网页的正文包含两个嵌套 div：第一个父 div 将节点的显示尺寸设置为视口宽度的 50%，父 div 包含的第二个 div 将其宽度设置为其父项的 50%，即视口宽度的 25% （网图侵删）<p>布局流程的输出是一个 盒模型，它会精确地捕获每个元素在视口内的确切位置和尺寸，当然，所有相对测量值都转换为屏幕上的绝对像素<br>我们先往下看，稍后还会给大家介绍<br>绘制(Painting)<br>经历了以上种种步骤，终于来到了 绘制 ，这一步听名字就能想到其作用了<br>经由前几步我们知道了哪些节点可见、它们的计算样式以及几何信息，我们将这些信息传递给最后一个阶段将渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 绘制 或 栅格化<br>绘制 过程中有一种绘制叫 重绘，也就是下我们要说的<br>重绘(Repaint)<br>元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了，这叫做 重绘 ( Repaint )<br>回流 (Reflow)<br>上面我们已经说过了 回流 ，当然也叫 重排 ，要知道，回流 一定伴随着 重绘 ，重绘 却可以单独出现，对比来看，显然回流的成本开销要高于重绘，而且一个节点的回流往往还会导致子节点以及同级节点的回流，所以优化方案中一般都包括，尽量避免 回流<br>什么会引起回流</p><p>页面渲染初始化</p><p>DOM结构改变，比如删除了某个节点</p><p>render树变化，比如减少了padding</p><p>窗口 resize</p><p>某些 JS 属性，引发回流，很多浏览器会对回流做优化，等到数量足够时做一次批处理回流，<br>但除了 render树 的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效</p><p>offset ( Top/Left/Width/Height )</p><p>scroll ( Top/Left/Width/Height )<br>cilent ( Top/Left/Width/Height )<br>width, height<br>调用了 getComputedStyle() 或者IE的 currentStyle</p><p>如何减少和避免回流重绘<br>上面我们说到，回流开销太大了，那么我们肯定是要优化的，接着看，其实就是尽量避免上面那些操作</p><p>减少逐项更改样式，最好一次性更改 style，或者将样式定义为 class 并一次性更新<br>避免循环操作DOM，让DOM离线后再修改</p><p>创建一个 documentFragment ，在它上面应用所有DOM操作，最后再把它添加到 window.document<br>先把DOM节点 display:none ( 会触发一次 reflow)，然后做修改后，再把它显示出来<br>克隆一个DOM节点在内存里，修改之后，与在线的节点相替换</p><p>避免多次读取offset等属性，无法避免则将它们缓存到变量<br>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高<br>改变字体大小也会引发回流，所以尽可能减少这种操作<br>table布局，一个小改动会造成整个table的重新布局，所以，少用为好</p><p>总之，说来说去，回流重绘，特别是回流，特别耗费资源，尽量避免就好，关于一些CSS属性会引起的回流重绘，可以去这个网站查查看 csstriggers.com/<br>合成(Composite)<br>终于来到了最后一个点 合成 ，我们先来总结一下上面的步骤，到目前我们经历渲染过程如下</p><p>首先解析 HTML 文档，形成 DOM 树<br>接着解析 CSS，产生 CSSOM树<br>在DOM和CSSOM树解析过程中，遇到 JS，会立即阻塞DOM树的构建，JS解析完成，接着走上面两步<br>再接着，浏览器通过DOM和CSSOM树构建渲染树 ( Render树 )</p><p>这个过程中，DOM中不可见标签元素不会放到渲染树中，就像<head></head> 或 display:none<br>CSSOM树规则会附加给渲染树的每个元素上</p><p>渲染树构建完成，浏览器会对这些元素进行定位和布局，这一步也叫 重排/回流 ( Reflow) 或 布局(Layout )<br>接下来绘制这些元素的样式，颜色，背景，大小及边框等，这一步也叫做 重绘 (Repaint)<br>再接下来是我们这最后一步合成( composite )，浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上</p><p>关于合成这一步骤，准备细聊一下子，让大家对其有个基本概念，因为刚开始忽略了它<br>首先，我们需要简单了解一些基本概念<br>浏览器渲染方式<br>浏览器在渲染图形的时候，有一个绘图上下文，绘图上下文又分成两种类型</p><p>第一种是用来绘制2D图形的上下文，称之为2D绘图上下文（GraphicsContext）<br>第二种是绘制3D图形的上下文，称之为3D绘图上下文（GraphicsContext3D）</p><p>网页也有三种渲染方式</p><p>软件渲染（CPU内存）<br>使用软件绘图的合成化渲染（GPU内存）CSS3D、WebGL<br>硬件加速的合成化渲染（GPU内存）</p><p>当然，这些我们也不需要深入理解，知道它们的存在即可<br>软件渲染技术<br>Webkit 在不需要硬件加速内容的时候（包括但不限于 CSS3 3D变形、CSS3 3D变换 、 WebGL 和 视频），它就可以使用 软件渲染技术 来完成页面绘制<br>上面我们看到了软件渲染技术，它是什么呢？我们接着看<br>对于每个渲染对象，需要三个阶段绘制自己</p><p>第一阶段是绘制该层中所有块的背景和边框<br>第二阶段是绘制浮动内容<br>第三阶段是前景 ( Foreground ) ，也就是内容部分、轮廓、字体颜色、大小等 ( 内嵌元素的背景、边框等发生在这一阶段 )</p><p>硬件加速技术<br>硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页 ( GPU的作用主要是用来绘制3D图形并且性能很 nice )<br>普通图层和复合图层<br>浏览器渲染的图层一般包含两大类：普通图层 以及 复合图层<br>普通文档流大家就可以理解为一个复合图层，我们叫它默认复合层，因为里面不管添加多少元素，其实都是在同一个复合图层中，absolute 布局、 fixed 也一样，虽然可以脱离普通文档流，但它仍然属于 默认复合层<br>复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能，但也不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡，因小失大<br>GPU中，各个复合图层是单独绘制的，所以也互不影响，通过 硬件加速 的方式，会声明一个 新的复合图层 ，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响 默认复合层 里的回流重绘<br>何为复合图层/硬件加速<br>复合图层或者说硬件加速，其实就是仅触发合成 composite ，那么也就必须符合以下三个条件</p><p>不影响文档流<br>不依赖文档流<br>不会造成重绘</p><p>寻思一下，可以做到这种情况得还真的不多 ( Chrome )</p><p>最常用的方式是 transform<br>opacity 属性 / 过渡动画 (需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态)<br>will-chang 属性 (这个比较偏僻)，一般配合 opacity 与 translate 使用，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层，作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作 (最好用完后就释放)<br><canvas> <webgl> 等元素<br>还有以前的 flash 插件等等</p><p>通俗一点，假如我们给一个元素加了 transform 属性吧，那么该元素就不会影响也不会依赖文档流，也不会造成重绘，就变成了一个复合图层，也就可以说我们对它使用了传说中的 硬件加速技术<br>absolute？<br>到了这里，大家可能有些迷惑，我们不是常说 absolute 是脱离文档流吗，为什么上面复合图层或者说硬件加速中没有 absolute 呢<br>其实，absolute 虽然可以脱离普通文档流，但是无法脱离默认复合层，就像它的 left 属性可以使用百分比的值，依赖于它的 offset parent<br>所以，就算 absolute 中信息改变时不会改变普通文档流中的 渲染树 ，但浏览器最终绘制时，是整个复合层绘制的，所以 absolute 中信息改变，仍会影响整个复合层的绘制，浏览器还是会重绘它，如果复合层中内容多，absolute 带来的绘制信息变化过大，资源消耗也非常严重<br>而我们上面说的硬件加速，那直接就是在另一个复合层了，所以它的信息改变不会影响默认复合层，当然内部肯定会影响属于自己的复合层，仅仅是引发最后的合成渲染<br>页面渲染优化<br>浏览器对上文介绍的关键渲染步骤进行了很多优化，针对每一次变化产生尽量少的操作，还有优化判断重新绘制或布局的方式等等，据上文所述，总结下页面渲染这块的优化实践，不分先后，大家也可一块来补充</p><p>HTML文档结构层次尽量少，最好不深于六层</p><p>JS 脚本尽量后放</p><p>样式结构层次尽量简单</p><p>少量首屏样式使用内联方式放在标签内</p><p>在脚本中尽量减少DOM操作，尽量访问离线DOM样式信息，避免过度触发回流</p><p>减少通过 JS 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画</p><p>尽量减少浏览器重排和重绘的一些情况发生</p><p>2020年了！就不要使用 table 布局了</p><p>CSS 动画中尽量只使用 transform 和 opacity ，不会发生重排和重绘</p><p>隐藏在屏幕外，或在页面滚动时，尽量停止动画</p><p>尽可能只使用 CSS 做动画，CSS动画肯定比 JS 动画要好很多</p><p>避免浏览器的隐式合成</p><p>改变复合层的尺寸</p><p>最后<br>上面讲的有些随意，最后再来波官方点的总结吧<br>发起一个请求，我们拿到了页面，下载完的网页将被交给浏览器内核（渲染进程）进行处理</p><p>首先，根据顶部定义的DTD类型进行对应的解析方式<br>渲染进程内部是多线程的，网页的解析将会被交给内部的GUI渲染线程处理<br>渲染线程中的HTML解释器，将HTML网页和资源从字节流解释转换成字符流<br>再通过词法分析器将字符流解释成词<br>之后经过语法分析器根据词构建成节点，最后通过这些节点组建一个DOM树<br>这个过程中，如果遇到的DOM节点是 JS 代码，就会调用 JS引擎 对 JS代码进行解释执行，此时由 JS引擎 和 GUI渲染线程 的互斥，GUI渲染线程 就会被挂起，渲染过程停止，如果 JS 代码的运行中对DOM树进行了修改，那么DOM的构建需要从新开始<br>如果节点需要依赖其他资源，图片/CSS等等，就会调用网络模块的资源加载器来加载它们，它们是异步的，不会阻塞当前DOM树的构建<br>如果遇到的是 JS 资源URL（没有标记异步），则需要停止当前DOM的构建，直到 JS 的资源加载并被 JS引擎 执行后才继续构建DOM<br>对于CSS，CSS解释器会将CSS文件解释成内部表示结构，生成CSS规则树<br>然后合并CSS规则树和DOM树，生成 Render渲染树，也叫呈现树<br>最后对 Render树进行布局和绘制，并将结果通过IO线程传递给浏览器控制进程进行显示</p><p>页面渲染篇到此就结束了，又是上万字，好像也没讲太多东西，大家还是只能以庞观的方式去了解，私下想深入的话还是要多看些相关资料，此文也是我看了很多资料输出的，看完本文，再去看资料或深入应该也会容易了解一些吧，这几篇帖子的核心都脱离不了那道经典面试题，那么看到了这里基本的一些知识点都已经给大家阐述过了，可以自己尝试总结一番了，一定要自己总结再看下文总结篇，这样大家也算没白浪费时间</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;接上文，上文我们讲了网络通信的部分，详细请看 「一道面试题」输入URL到渲染全面梳理上-网络通信篇 ，那么该说说页面渲染的流程了，也就是当输入一个URL拿到了页面后，浏览器怎么解析，怎么呈现&lt;/p&gt;</summary>
    
    
    
    
    <category term="转载" scheme="http://havebear.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>输入URL到渲染全面梳理上-网络通信篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.132Z</published>
    <updated>2025-07-18T06:03:17.132Z</updated>
    
    <content type="html"><![CDATA[<p>从输入 URL 到页面渲染发生了什么？比如在浏览器输入了 <a href="http://www.qq.com/">www.qq.com</a> 后浏览器是怎么把最终的页面呈现，这是一个非常经典的面试题，不管是大公司还是小公司甚至前端或后端的面试中命中率都极高，因为涉及到的知识点和可挖掘的地方比较多，而且这中间几乎每一步都是可以优化的。文章很长，原作者分成了三个篇幅，分别从 网络通信 和页面渲染 两个方面描述</p><span id="more"></span><style> .light { color: red } </style><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>URL从输入到页面渲染这整个过程可以分为 网络通信 和 页面渲染 两个方面，一般后端程序猿回答这个问题侧重网络通信就行了，但是前端页面渲染也得了解，总之回答的越详细分值越高</p><p>那么开始吧，这篇文章我们先来看网络通信方面，可能前端同学大家对网络方面的认知应该没有后端同学强，其实这道面试题最能突出自己的也是网络方面，因为它涉及到了很多网络通信原理的知识，所以这块咱们慢慢梳理</p><h2 id="网络分层的由来"><a href="#网络分层的由来" class="headerlink" title="网络分层的由来"></a>网络分层的由来</h2><p>不晓得大家知不知道网络分层，网络其实有很多层，层与层之间又有好多协议存在，还有各种各样的数据包，这玩意干巴巴的，很没意思，这么多层太麻烦了，为什么有这么多层呢？为什么不直接一层呢？</p><p>起初计算机与计算机之间的通信只需要一根线就可以完成通信，但是世界那么大，那么多计算机，距离太远了，而且这线还老容易被无良的人偷偷剪断</p><p>后来就出来了无线网，虽然其中网关、路由之间也需要连线，但不是让每台计算机两两连接，而是一个区域为单位计算机相互连接通信</p><p>后来发现计算机之间的连线只能传送0/1信号，另一台计算并不知道那么多0/1代表什么，就像 <span class="light"> 010101010101111000111011010 </span>你知道这一大串是什么意思吗，计算机也不知道，不同厂商生产的计算机连线实现通信也是很麻烦的，干脆定义一套规则吧，不管是哪个牌子的计算机，都必须遵守这套规则，这套规则就是我们经常说的 <span class="light">网络协议</span></p><p>哦哦，是在说 网络分层 ，不是讲 网络协议 ，继续继续，接着我们上面的话题，问题来了，计算机之间通过连线传送0/1信号的问题虽然规定了通信规则，但是除了像0/1这种无意义的信号之外，网络中还存在着其他各种各样的问题</p><ul><li>两个计算机之间怎么进行识别？</li><li>怎么才能知道对方的地址？</li><li>不同计算机应用程序怎么知道是给自己传递的数据？</li><li>不同的通信数据格式怎么来规定等等一系列的问题</li></ul><p>如果各种问题都写成一套协议来规定双方通信的规则，但是万一其中哪些规则通信中出现问题，影响到了其他规则，最常见的就是数据包，一个数据包中如果包含各种各样的协议</p><p>如果我们对网络进行分层，每一层负责一项具体的工作，然后把数据传送到下一层，那么往来通信和网络互联这一复杂的问题是不是就变得较为简单化了呢</p><h2 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h2><p>目前的网络层次可划分为 <span class="light">四层因特网协议栈</span> 和 <span class="light">七层因特网协议栈</span> ，其实起初网络分层是标准的七层，也就是我们所说的 <span class="light">OSI 七层模型</span> ，参考模型是国际标准化组织 <span class="light">ISO</span> 制定的一个用于计算机或通信系统间互联的标准体系，一般称为 <span class="light">OSI参考模型</span> 或 <span class="light">七层模型</span></p><p>可能对网络有些了解的同学知道还有 <span class="light">TCP/IP 四层模型</span> 和 <span class="light">TCP/IP 五层模型</span> ，这又是怎么出来的呢？</p><p>其实所谓的 <span class="light">TCP/IP 四层模型</span> 和 <span class="light">TCP/IP 五层模型</span> 是以 <span class="light">OSI 七层</span> 优化而来，把某些层进行合并了，本质上还是相同的，<span class="light">OSI七层模型</span> 太过细化，有一定的参考意义，但实现起来比较繁琐，相比较而言，<span class="light">TCP/IP模型</span> 比较简洁，具有较强的实际应用价值</p><p>我们来看一个模型的图片 ( 网图侵删 )</p><p><img src="http://qiniu.havebear.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg"></p><p><span class="light">TCP/IP</span> 将计算机网络分成了四个层次，一般资料或教程里都是结合 <span class="light">OSI7层模型</span> 和 <span class="light">TCP/IP4层模型</span>，将计算机网络按照5层的模型来讲，5层模型只是为了方便介绍计算机网络原理而设计的，而在实际应用中还是 <span class="light">TCP/IP四层模型</span> ，这点大家要明白</p><p>这里我们同样用五层来解释，比较好理解些，当然，这里只能让大家脑海里有一个具体的网络分层结构的认知，作为面试回答了解这些足够，而后推荐大家继续深入，可以看相关的书籍和资料，此文也能够起到一个引导的作用</p><p>PS： 作为一个前端或者是后端，我们都是软件开发，所以侧重点放在网络层以上就可以了，物理层和数据链路层都是硬件相关的，所以这两个层下面不会过多叙述，了解即可</p><h2 id="物理层（physical-layer）"><a href="#物理层（physical-layer）" class="headerlink" title="物理层（physical layer）"></a>物理层（physical layer）</h2><p>物理层，顾名思义，通过物理手段 ( 网线，光纤，无线 ) 将设备连接在一起，传输0/1电信号 ( 也叫比特流 ) ，就像我们上边讲到的计算机之间的物理连线</p><p>主要用来传输0/1信号，因为0/1信号没有任何的现实意义，所以用另一层用来规定不同0/1组合的意义</p><h2 id="数据链路层（data-link-layer）"><a href="#数据链路层（data-link-layer）" class="headerlink" title="数据链路层（data link layer）"></a>数据链路层（data link layer）</h2><p>还是上面说的，<span class="light">010101010101111000111011010</span> ，像这么一串数据计算机并不知道是什么意思</p><p>下层的物理层不能规定不同0/1组合的信号代表什么意义，所以在数据链路层规定了一套协议，专门给0/1信号进行分组，规定不同的组代表的是什么意思，从而让双方计算机都能够进行识别，这个协议就是我们常说的 <span class="light">以太网协议</span></p><h3 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h3><p>以太网协议规定一组电信号构成一个数据包，我们把这个数据包称为 <span class="light">帧</span> ，每一个帧由 <span class="light">标头</span> 和 <span class="light">数据</span> 两部分组成<br>帧的大小一般为 <span class="light">64 - 1518</span> 个字节 较大的数据则需要分成多个桢</p><p>标头 <span class="light">Head</span> ，18个字节组成，标头中包含这个 <span class="light">桢</span> 是由谁发送、发送给谁这些信息，所以标头主要是一些说明数据 例如发送者/接受者等信息</p><p>数据 <span class="light">Data</span> ，46-1500个字节组成，里面主要是发送者想给接收者的内容</p><p>把一台计算机的数据通过物理层和数据链路层发送给另外一台计算机，怎么标识对方以及怎么知道对方的地址呢？ 唯一标示 <span class="light">MAC地址</span> 出现了</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>进入网络的每一台计算机，都会有网卡接口，每一个网卡都会有一个唯一的地址，就是所谓的 <span class="light">MAC地址</span> ，它就是网络中每台计算机设备的唯一标识，是一串由48个字节组成的十六进制数，每台计算机在厂商生产出来的时候就标识好了，所以我们用 <span class="light">MAC地址</span> 来标识对方</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171927bef8f41164?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>如上图所示，如计算机A知道了计算机B的MAC地址，然后计算机A想要给计算机B传送数据，虽然计算机A知道了计算机B的MAC地址，可是A要怎么给B传送数据呢？</p><p>计算机A不仅连着计算机B，而且计算机A也连接着计算机C和D，虽然计算机A知道计算机B的MAC地址，但是却不知道B是在哪一路上，所以为了解决这个问题，<span class="light">广播</span> 这个概念就出现了</p><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>在同一子网络，就是我们常说的局域网中，计算机通过广播来通信，即向同子网中全部计算机发送数据包，其它计算机根据数据包中接收者的 <span class="light">MAC地址</span> 来判断是否接收数据包</p><p>通俗来讲，就是A会同时给B/C/D发送数据包，这个数据包中会包含着接收者的 <span class="light">MAC地址</span> 信息，当B/C/D接收到了数据包，会取出数据包中的 <span class="light">MAC地址</span> 与自身的 <span class="light">MAC地址</span> 对比，如相同就接收这个数据包，否则就丢弃这个数据包 (  丢包 )，这种方式我们称之为 <span class="light">广播</span></p><p>就像，你和女友在人群中走散了，你大喊一声她的名字，听到的人会自己匹配，是自己就会理会，不是自己就当你是傻子不理你</p><p>那么到了目前，我们知道了计算机之间的标示和如何通信，但是还有一个问题，要怎么知道对方的 <span class="light">MAC地址</span> 呢 ？这又牵出了 <span class="light">ARP协议</span> ，通过 <span class="light">ARP协议</span> 来得知对方的 <span class="light">MAC地址</span> ，这个协议是网络层的一个协议，所以我们暂且搁置，先接着往下看</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>看了物理层和数据链路层的作用，可能大家会觉得好像已经可以完成正常通信了，那么网络层又是做什么的呢？</p><p>其实我们所处的网络，是由无数个子网络 ( 局域网 ) 构成的，广播的时候，也只有同一个子网里的计算机能够收到，如过没有子网这种东西，计算机A通过广播的方式发一个数据包给计算机B，那么全世界所有的计算机都能收到这个数据包，然后进行对比再舍弃，那么多台计算机后果可想而知，子网也因此而产生</p><p>那么问题又来了，我们要怎么区分 <span class="light">Mac地址</span> 是属于同一个子网的呢？假如是同一个子网，我们就用广播的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据发给网关，让网关进行转发</p><p>怎么判断两台计算机是否在同一个子网中呢，这就是网络层干的事情，为了解决这个问题，就有了 <span class="light">IP协议</span> 的概念</p><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p><span class="light">IP协议</span> 所定义的地址，就是我们常说的 <span class="light">IP地址</span> ，<span class="light">IP协议</span> 有两个版本，<span class="light">ipv4 / ipv6</span>，目前用的最多的还是 <span class="light">ipv4</span>，这个地址由<span class="light">3</span>2位的二进制数组成，我们一般把它分成<span class="light">4</span>段的<span class="light">十进制</span>表示，地址范围在 <span class="light">0.0.0.0 ~ 255.255.255.255</span> ，这个我们应该都很常见<br>每一台想要联网的计算机都会有一个 <span class="light">IP地址</span> ，这个 <span class="light">IP地址</span> 分为两部分，前面一部分代表网络，后面一部分代表主机，但是网络部分和主机部分所占用的二级制位数是不固定的<br>假如两台计算机的网络部分是一模一样的，我们就说这两台计算机是属于同一个子网 ( 局域网 ) 中，例如 <span class="light">192.168.17.1</span> 和 <span class="light">192.168.17.2</span> ， 假如这两个 <span class="light">IP地址</span> 的网络部分为 <span class="light">24</span> 位，主机部分为 <span class="light">8</span> 位，那么他们的网络部分都为 <span class="light">192.168.17</span> ， 所以我们说这两台计算机处于同一个子网中<br>问题又随之而来了，给我们两个 <span class="light">IP地址</span> ，鬼知道网络部分占几位，主机部分又占几位呢？<br>这就又引出了我们另一个关键词 <span class="light">子网掩码</span></p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p><span class="light">子网掩码</span> 和 <span class="light">IP地址</span> 一样也是<span class="light">32位</span>二进制数，但是它的网络部分规定全部为<span class="light">1</span>，主机部分规定全部为<span class="light">0</span>，也就是说假如上面那两个 <span class="light">IP地址</span> 的网络部分为<span class="light">24</span>位，主机部分为<span class="light">8</span>位的话，那他们的子网掩码为<br><span class="light">11111111.11111111.11111111.00000000</span> ，也就是 <span class="light">255.255.255.0</span><br>有了子网掩码，怎么来判断 IP地址 是否处于同一个子网中呢？<br>显然，知道了子网掩码，相当于我们知道了网络部分是几位，主机部分是几位，我们只需要把 <span class="light">IP地址</span> 与他的子网掩码做一个 ( and ) 运算，然后把各自的结果进行比较就行了，如果比较的结果相同，则代表的是同一子网，否则不是同一子网<br>也就是说有了两台计算机的 <span class="light">IP地址</span> 和 <span class="light">子网掩码</span> ，我们就可以判断他们是否处在同一子网当中了<br>假设他们处在同一子网当中，计算机A要和计算机B发送数据时，我们通过是 <span class="light">ARP协议</span> 来得到计算机的 <span class="light">MAC地址</span></p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p><span class="light">ARP协议</span> 也是通过广播的形式，给同一个子网中每个电脑发送一个数据包，这个数据包会包含接收者的 <span class="light">IP地址</span>，对方收到这个数据之后，会取出 <span class="light">IP地址</span> 与自身的对比，相同则会把自己的 <span class="light">MAC地址</span> 回复给对方，否则就丢弃这个数据包，这样计算机A就知道计算机B的 <span class="light">MAC地址</span> 了<br>可能大家会问，知道了 <span class="light">MAC地址</span> 后，发送数据是通过广播的形式发送，询问对方的 <span class="light">MAC地址</span> 也是通过广播的形式来发送，那其他计算机怎么知道你是要传输数据还是询问 <span class="light">MAC地址</span> 呢？<br>其实在询问 <span class="light">MAC地址</span> 的数据包里，在对方的 <span class="light">MAC地址</span> 这儿填的是一个特殊的 MAC地址 ，其他计算机看到这个特殊的 <span class="light">MAC地址</span> 后，就知道广播是在询问了<br>如果两台计算机的 <span class="light">IP</span> 不是处于同一个子网之中，这个时候我们就会把数据包发送给网关，然后让网关帮我们进行转发</p><h2 id="运输层（transport-layer）"><a href="#运输层（transport-layer）" class="headerlink" title="运输层（transport layer）"></a>运输层（transport layer）</h2><p>通过 <span class="light">物理层</span> / <span class="light">数据链路层</span> 以及 <span class="light">网络层</span> 的互相协调，我们成功的把数据从计算机A传到了计算机B，可是计算机B里面有各式各样的应用程序，计算机是如何知道这个数据是发给哪个应用程序的呢？<br>这个时候，<span class="light">端口</span> 就上场了，当计算机A传输给计算机B的时候，还得指定一个端口，以供特定的应用程序来接收处理，作为程序员的我们对端口就更熟悉了，端口范围：<span class="light">0~65535</span>，其中前1023个端口被系统占用<br>那么也就是说，传输层的功能就是建立端口到端口的通信，而相比之下网络层的功能是建立主机到主机的通信<br>有了 <span class="light">IP</span> 和 <span class="light">端口</span> ，我们才能准确通信，我们输入的IP有些并没有指定端口号，其实是有些传输协议，设定了一些默认端口，例如 HTTP 默认是80，HTTPS 默认是443，这些端口信息也会包含在数据包里面<br>传输层最常见了两大协议就是 <span class="light">TCP协议</span> 和 <span class="light">UDP协议</span></p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p><span class="light">UDP协议</span> 全称是<span class="light">用户数据报协议</span>，是一种<span class="light">无连接</span>的协议，与TCP协议一样用于处理<span class="light">数据包</span><br>UDP数据包分 <span class="light">标头</span> (8个字节) 和 数据 (加标头不超过65535个字节)， UDP数据包放在IP数据包的 <span class="light">数据</span> 中，标头主要包括发出端口和接收端口<br>UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的</p><h4 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h4><p><span class="light">面向无连接</span></p><ul><li>UDP 想发数据就可以开始发送了，不需要连接，它只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作</li><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li><li>有单播、多播、广播</li><li>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能</li></ul><p><span class="light">面向报文</span></p><ul><li>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层</li><li>UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界</li><li>因此，应用程序必须选择合适大小的报文</li></ul><p><span class="light">不可靠性</span></p><ul><li>不可靠性首先体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠</li><li>收到什么数据就传什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了</li><li>网络环境时好时坏，但 UDP 没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整，这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景 ( 比如电话会议 ) 就需要使用 UDP 而不是 TCP</li></ul><p><span class="light">头部开销小，传输数据报文高效</span></p><ul><li>UDP 头部包含了以下几个数据<ul><li>两个十六位的端口号，分别为发出端口和接收端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul></li><li>所以UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的</li></ul><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据</p><ul><li>例如你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容</li><li>又例如当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分</li></ul><p>如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了 <span class="light">TCP</span><br><span class="light">TCP协议</span> 全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，<span class="light">TCP</span> 是<span class="light">面向连接的、可靠的流协议</span>，什么是流？<span class="light">流就是指不间断的数据结构</span>，可以把它想象成排水管中的水流</p><h4 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h4><p><span class="light">面向链接</span></p><ul><li>面向连接，是指发送数据之前必须在两端建立连接，建立连接的方法就是 三次握手，这样能建立可靠的连接，为数据的可靠传输打下了基础</li></ul><p><span class="light">仅支持单播传输</span></p><ul><li>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式</li></ul><p><span class="light">面向字节流</span></p><ul><li>TCP不像UDP一样那样一个个报文独立传输，而是在不保留报文边界的情况下以字节流方式进行传输</li></ul><p><span class="light">可靠传输</span></p><ul><li>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号，TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收</li><li>然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)，如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传</li></ul><p><span class="light">提供拥塞控制</span></p><ul><li>当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞</li></ul><p><span class="light">全双工通信</span></p><ul><li>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据</li><li>当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</li></ul><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>三次握手建立连接，为方便理解，仿一次电面</p><ul><li>小李 (客户端)：您好，您是xx的面试官吗？</li><li>面试官 (服务端)：嗯嗯，是的，你是昨天投简历的小李吗？</li><li>小李 (客户端)：嗯嗯，是的，我是</li></ul><p>接着，小李和面试官开始愉快的侃起了大山</p><!-- 根据上述内容，看下图： --><!-- ![](https://user-gold-cdn.xitu.io/2020/4/19/171927bf022d61d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) --><p>三次握手流程如下</p><ul><li><span class="light">第一次握手</span> 客户端向服务端发送连接请求报文段，该报文段中包含自身的数据通讯初始序号，请求发送后，客户端便进入 SYN-SENT 状态</li><li><span class="light">第二次握手</span> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态</li><li><span class="light">第三次握手</span> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文，客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功</li></ul><p>出现三次握手的原因是为了 <span class="light">防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误</span></p><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>四次挥手断开链接，接着仿电面</p><ul><li>面试官 (主动方)：嗯，你的情况我这边了解了，等通知吧 ( 我想挂了 )</li><li>小李 (被动方)：嗯嗯，好的 ( 这就想挂了？我还没侃够 )</li><li>小李 (被动方)：那希望有机会能和您一块共事 ( 拜拜吧您嘞 )</li><li>面试官 (主动方)：嘀…嘀…嘀…嘀</li></ul><!-- 根据上述内容，看下图： --><!-- ![](https://user-gold-cdn.xitu.io/2020/4/19/171927bf0c20e4e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) --><p>四次挥手流程如下</p><ul><li><span class="light">第一次挥手</span> 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求</li><li><span class="light">第二次挥手</span> B 收到连接释放请求后，会告诉应用层要释放 TCP 链接，然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了，但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A</li><li><span class="light">第三次挥手</span> B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态</li><li><span class="light">第四次挥手</span> A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态，当 B 收到确认应答后，也便进入 CLOSED 状态</li></ul><h4 id="为何客户端最后还等待2MSL"><a href="#为何客户端最后还等待2MSL" class="headerlink" title="为何客户端最后还等待2MSL"></a>为何客户端最后还等待2MSL</h4><p>客户端需要保证最后一次发送的 <span class="light">ACK</span> 报文到服务器，如果服务器未收到，可以请求客户端重发，这样客户端还有时间再发，重启 2MSL 计时</p><h4 id="TCP-IP的并发限制"><a href="#TCP-IP的并发限制" class="headerlink" title="TCP/IP的并发限制"></a>TCP/IP的并发限制</h4><p>其实浏览器对同一域名下并发的 TCP 连接是有限制的（2-10个不等）<br>而且在 HTTP1.0 中往往一个资源下载就需要对应一个 TCP/IP 请求</p><h4 id="UDP协议和TCP协议的区别"><a href="#UDP协议和TCP协议的区别" class="headerlink" title="UDP协议和TCP协议的区别"></a>UDP协议和TCP协议的区别</h4><table><thead><tr><th>对比</th><th align="right">UDP</th><th align="center">TCP</th></tr></thead><tbody><tr><td>是否连接</td><td align="right">无连接</td><td align="center">面向连接</td></tr><tr><td>是否可靠</td><td align="right">不可靠传输，不使用流量控制和拥塞控制</td><td align="center">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>连接个数</td><td align="right">支持一对一，一对多，多对一和多对多通信</td><td align="center">只能一对一通信</td></tr><tr><td>传输方式</td><td align="right">面向报文</td><td align="center">面向字节流</td></tr><tr><td>首部开销</td><td align="right">首部开销小，仅8字节</td><td align="center">首部最小20字节，最大60字节</td></tr><tr><td>适用场景</td><td align="right">适用于实时应用 ( IP电话、视频会议、直播等 )</td><td align="center">适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><ul><li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务</li><li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li><li>对数据准确性要求高，速度可以相对较慢的，可以选用 TCP</li></ul><h2 id="应用层（Application-layer）"><a href="#应用层（Application-layer）" class="headerlink" title="应用层（Application layer）"></a>应用层（Application layer）</h2><p>应用层是最接触用户的，上面几层我们收到了传输层收到的数据，TCP/UDP协议可以传递各种程序的数据包，就像邮箱/网页/FTP等等，所以就需要不同的协议来规定数据的格式，收到后才能渲染解读，应用层就是由这些协议构成，它的数据包放在UDP包/TCP包的 数据 中<br>我们遨游网络时经常用到的 HTTP 协议、文件传输用的 FTP 协议、电子邮件发送的 SMTP、域名解析的 DNS 协议、远程登录的 Telnet 协议等等都是属于应用层的<br>还有Socket，它是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作封装成几个简单的接口供应用层调用，从而实现进程在网络中的通信<br>上面我们已经基本了解到了计算机的一些通信基础，可以说到目前为止从一个IP到通信结束都已经知道了，但是我们输入的是域名不是IP，那么它是怎么变成IP通信的呢？这就要详细说说 DNS 了</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h4><p>Domain Name System 简写 DNS ，翻译过来就是域名系统的意思，它是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络，作为将域名和IP地址相互映射的一个分布式数据库，它所提供的服务是用来将 主机名 和 域名 转换为 IP地址 的工作<br>简单来说，IP地址 就像门牌号一样，我们在输入域名访问网站时，数据服务器是不认识你这个域名的，它只认识IP，你的域名会通过 DNS服务器 解析成IP值，通过这个门牌号 (IP值) 向数据服务器查找你的网站数据并给你返回到浏览器上</p><h4 id="为什么需要DNS"><a href="#为什么需要DNS" class="headerlink" title="为什么需要DNS"></a>为什么需要DNS</h4><p>上面我们说，网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如 252.94.131.12 之类的IP地址，而不能认识域名<br>我们没办法记住10个以上IP地址的网站 ( 你要说记性好那俺就乖乖闭嘴了😄 )，一般我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫 DNS服务器 的计算机自动把我们的域名 翻译 成了相应的IP地址，然后通过 IP地址 返回所对应的网页</p><h4 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;从输入 URL 到页面渲染发生了什么？比如在浏览器输入了 &lt;a href=&quot;http://www.qq.com/&quot;&gt;www.qq.com&lt;/a&gt; 后浏览器是怎么把最终的页面呈现，这是一个非常经典的面试题，不管是大公司还是小公司甚至前端或后端的面试中命中率都极高，因为涉及到的知识点和可挖掘的地方比较多，而且这中间几乎每一步都是可以优化的。文章很长，原作者分成了三个篇幅，分别从 网络通信 和页面渲染 两个方面描述&lt;/p&gt;</summary>
    
    
    
    
    <category term="转载" scheme="http://havebear.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>输入URL到渲染全面梳理下-总结篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-18T06:03:17.132Z</published>
    <updated>2025-07-18T06:03:17.132Z</updated>
    
    <content type="html"><![CDATA[<p>此文是一道面试题，又不仅仅是一道面试题，你会发现，这题不论大厂小厂，都会问，为什么<br>因为它足够经典，连续写了三篇帖子，每篇都上万字，依然感觉不够细，涉及的点真的很考验一个人的知识覆盖率，还是多方面的考验，如果让我来面试的话，我觉得完全可以通过这一道题挖掘出面试者的基础知识储备量，延展性更是超强<br>SO，答好它可以让面试官眼前一亮，让你与众不同<br>此文是总结篇，没有看过前两篇的小伙伴建议先看看，然后自己总结总结，再来看这篇，因为前两文是为了能够看懂此文才写的<br>「一道面试题」输入URL到渲染全面梳理上-网络通信篇<br>「一道面试题」输入URL到渲染全面梳理中-页面渲染篇<br>如果你都看过了，那就来一块总结吧，首先，还请为我的疯狂码字点个赞再看哦，最近打字速度都快了不少 😄<br>回顾？<br>本来这块儿会简单回顾下前两文知识点再进行总结的，还有一个思维导图，原本已经写的差不多了，大概有个1万字了，后来写着写着被我删了大半重新写了<br>因为某天心血来潮，想把整篇文章换成一面试的问答帖，写帖嘛，我比较喜欢 认真且随心所欲 ，就删了重来了，所以此文才会慢了些<br>下文会以一个面试官和面试者问答的过程来描述这些个问题，主体问题答完之后还会有一些比较常见的主体发散的问题，最近得空看完了电视剧 鬓边不是海棠红 ，看的说话都有点被带跑偏了，用剧中 老北京腔 来说就是 得，您瞧好吧！😄 ，好了，调侃完毕，开始正经了，干巴巴的万字小文来了，做好准备哦<br>首先请带入你自己，你就是一个面试者，仔细看每道题，先静心想一会，然后在心中回答，最后再看总结的答案 ( 此答案也不一定对，个人感悟，只给大家做参考，也望大家给予补充或指正 )<br>问(主体)：输入URL到页面渲染都经历了什么？<br>个人觉得 ，不要急着回答，先思考30秒，在心中形成一个大致步骤的轮廓，先概括，然后再慢慢道来，注意节奏，中间也可以短暂停顿思考，面试官不会因为你想了一会就 pass 掉你，相反，你直接脱口而出一堆内容，会让面试官觉得你像是背课文<br>对于主体问题，写了两种回答，觉得需要注意两点来选择性回答，至少我这么觉得<br>面试官的状态<br>大致判断面试官是一个什么样的人，注意面试官这个人的状态，这很重要，通过对面试官当时状态的判断来决定精简回答或是轰炸式回答，这里的轰炸式回答不是说越多越好，说的是我们在回答的时候顺带牵出一些知识点来证明我们的知识量，但是不管怎样回答都要回答在点上，不要认为答得越多越好就扯一些有的没的，这大概就是察言观色吧<br>你的状态<br>你的状态就比较容易理解了，如果你对一些知识点掌握不牢靠或有些紧张，这个时候就不要死撑还争取回答的面面俱到了 (面试官面前不太懂硬装做什么都懂，容易引起些许反感)，尽量精简，把你熟的地方多说一点，这样可以对面试官进行一个暗示引导，然后等待让面试官发散问你，通常你哪里说的多，面试官就会往哪个方向发散，如果你足够自信，那就尽情说好了，不在意他的发散，只要不说没用的就👌，绝大多数面试官对于这种情况应该都会喜欢<br>一本正经的轰炸式回答<br>面试官你好，这个问题是一个经典问题，我业余时间也有仔细阅读过一些相关书籍，做过一些总结，因为涉及到的知识点很多，所以可能会花一些时间，如果中间您有什么问题或者我的回答有不正确，还请您随时打断我，为我指出错误，谢谢<br>我觉得从URL输入到页面渲染大体上可以分为网络通信 和 页面渲染 两个阶段<br>首先是网络通信阶段，在互联网中网络设备之间的通信都会遵循 TCP/IP四层协议，通过 TCP/IP 网络分层顺序与对方进行通信，分层由高到低分别为：应用层、传输层、网络层、数据链路层，我们浏览器输入URL也就是发送端会从 应用层 往下走，接收端也就是服务器会从 数据链路层 往上走，通常我们会用五层协议来解释，数据链路层这一层会分成物理层和数据链路层两层<br>浏览器输入URL<br>输入URL按下回车后，就进入了 应用层 开始往下走，浏览器会开一个线程来处理，先对URL进行解析，一般包括 ( 协议头、主机域名或IP地址、端口号、请求路径、查询参数、hash等等 )，然后打开网络线程发出一个完整的请求<br>应用层DNS解析域名<br>这其中DNS解析，也就是 域名或IP解析 是因为我们输入的URL通常都是一个域名，计算机不认识域名只知道IP，所以需要DNS解析通过域名查询得到对应IP，对于DNS解析时</p><p>首先会查看浏览器DNS缓存<br>没有的话就查询计算机本地DNS缓存<br>还没有就询问递归式DNS服务器（就是网络提供商，一般这个服务器都会有自己的缓存，所以IP查询大多都在这里完成）<br>如果依然没有缓存，那就需要通过 根域名服务器 和 TLD域名服务器 再到对应的 权威DNS服务器 找记录，并缓存到 递归式服务器，然后 递归服务器 再将记录返回给本地</p><p>应用层客户端发送HTTP请求<br>IP地址有了，应用层的客户端想看页面，就会发一个 HTTP 请求，HTTP 请求分为 请求报头 和 请求主体 ，请求主体就是客户端要发送给服务器或者服务器返回给客户端的内容，请求报头比较重要，包含通信方式也就是请求方法 (POST / GET / INPUT / DELETE等)、URI、协议版本号以及请求头部方法（Accept、Cache-Control…）<br>传输层TCP传输报文<br>应用层 发送了一个请求后，为了传输方便，在 传输层 会把从 应用层 接收到的数据 ( 就是那个HTTP请求报文 ) 进行分割，并为每个报文编号后再转发给 网络层，编号就是方便服务器接收时能准确地还原报文信息，这里用到了我们常说的 TCP协议<br>TCP协议 会通过 三次握手 保证传输的安全可靠，也可以这样说，客户端在 传输层 开始和服务器通过 三次握手 建立 TCP/IP 连接<br>所谓的 三次握手 ，就是发送端先发送一个带有 SYN ( synchronize ) 标志的数据包给接收端，在一定的延迟时间内等待接收端的回复，接收端收到数据包后，传回一个带有 SYN / ACK 标志的数据包以表示传达确认信息，接收方收到后再发送一个带有 ACK 标志的数据包给接收端以表示握手成功，在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止<br>也就是上一文说的</p><p>小李 (客户端)：您好，您是xx的面试官吗？</p><p>面试官 (服务端)：嗯嗯，是的，你是昨天投简历的小李吗？</p><p>小李 (客户端)：嗯嗯，是的，我是</p><p>网络层IP协议查询MAC地址<br>建立连接后 网络层 IP协议会查询 MAC地址 进行数据包的传输<br>通俗来说，IP协议 负责把各种数据包传送给接收方，因为要保证确实能传输到对方，所以需要确定接收方的 MAC地址 也就是我们说的物理地址，IP地址 可以和 MAC地址 通过映射表一一配对上，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的，而 IP 到 MAC 的解析过程则依赖于 ARP协议，它可以根据通信方的 IP地址 反查出对应的 MAC地址<br>因为一般通信双方是无法直接进行通信的（除非在同一局域网），会经过多台计算机或路由器来进行中转，所以也就需要 ARP 来一路确认下一个中转站，协助数据包的传输<br>数据到达数据链路层<br>找到对方的 MAC地址 后，就会将数据发送到 数据链路层传输，到此客户端发送请求阶段就结束了<br>服务器接收数据<br>而后接收端的服务器在 数据链路层 接收到数据包，再通过相反的方式将数据一层一层的还原回 应用层 ，这过程中包括在运输层那里通过TCP协议将分段的数据包重新组成原来的HTTP请求报文<br>请求到了后台服务器，一般来说会有统一的验证，如安全验证、跨域验证等，验证未通过就直接返回相应的HTTP报文，验证通过后，就会进入后台代码，此时程序收到请求，然后会执行对应的操作<br>如果浏览器访问过，且缓存上有对应的资源，就会与服务器最后修改时间对比，一致便返回304，告诉浏览器可使用本地缓存<br>服务器响应请求<br>服务器接收到客户端发送的HTTP请求后，会查找客户端请求的资源，并返回响应报文<br>另外现在很多网站都会有重定向功能，比如请求域名省去了 www.，它会给你重定向来添加上，这也就意味着第一次请求 HTML 的过程中我们是需要发起两次请求的<br>这样做的原因在于搜索引擎会认为 <a href="http://www.xxx.com/">www.xxx.com</a> 和 xxx.com 是两个网站，从而造成网站排名下降，还有如果两个地址都有打开过，会造成多余 ( 双倍 ) 的浏览器缓存<br>服务器返回相应文件<br>请求成功后，服务器会返回相应的网页，浏览器接收到响应成功的报文后便开始下载网页，至此，网络通信结束<br>解析HTML构建DOM Tree<br>拿到服务器返回的网页后，首先，根据顶部定义的DTD类型进行对应的解析方式，网页的解析将会被交给内部的GUI渲染线程处理<br>渲染线程中的HTML解释器，将HTML网页和资源从字节流解释转换成字符流，再通过词法分析器将字符流解释成词，之后经过语法分析器根据词构建成节点，最后通过这些节点组建一个DOM树<br>这个过程中，如果遇到的节点是 JS 代码，就会调用 JS引擎 对 JS代码进行解释执行，此时由于 JS引擎 和 GUI渲染线程 的互斥，GUI渲染线程 就会被挂起，渲染过程停止，如果 JS 代码的运行中对DOM树进行了修改，那么DOM的构建需要从新开始<br>如果节点需要依赖其他资源，图片/CSS等等，就会调用网络模块的资源加载器来加载它们，它们是异步的，不会阻塞当前DOM树的构建<br>如果遇到的是 JS 资源URL（没有标记异步），则需要停止当前DOM的构建，直到 JS 的资源加载并被 JS引擎 执行后才继续构建DOM<br>解析CSS构建CSSOM Tree<br>CSS解释器会将CSS文件解释成内部表示结构，生成CSS规则树，这个过程也是和DOM解析类似的，CSS 字节转换成字符，接着词法解析与法解析，最后构成 CSS对象模型(CSSOM) 的树结构<br>构建的过程中浏览器得递归 DOM 树来确定元素到底是什么样式，为了 CSSOM 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 DOM 已经构建完了，也得等 CSSOM，然后才能进入下一个阶段<br>构建渲染树 (Render Tree)<br>接着 CSSOM 树和 DOM 树 合并成渲染树，也叫呈现树，渲染树 只包含渲染网页所需的节点，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上<br>布局 (Layout)<br>渲染树 同时包含了屏幕上的所有可见内容及其样式信息，有了渲染树，再接着就会进入布局 ( layout ) 阶段了，到目前为止，浏览器计算了哪些节点应该是可见的以及它们的计算样式，但还没有计算它们在设备视口内的确切位置和大小，这就是 布局 ( Layout ) 阶段，也称为 自动重排 或 回流 ( Reflow )<br>此阶段一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树<br>绘制 (Painting)<br>经由前几步我们知道了哪些节点可见、它们的计算样式以及几何信息，将这些信息及渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 绘制 或 栅格化 阶段<br>合成(Composite)<br>最后一步合成( composite )，这一步骤浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上<br>至此上述的内容就是我理解的一个URL从解析到渲染的生命历程了<br>干净简洁的概括式回答<br>PS：这里大体的点我觉得还是要答出来的，可以根据自己的了解进行某些方面的扩展，至少我觉得是这样子的，也是个人理解，欢迎探讨<br>面试管你好，URL输入到页面渲染，这是一个经典的话题，涉及的知识点也很多，我按照我的个人理解给您简单概括下，有不对的地方还请您指出<br>首先，客户端浏览器输入URL，由于是域名，应用层DNS开始解析域名<br>接着，应用层客户端发送一个HTTP请求，把拿到的应用层HTTP请求报文数据分割编号，为了方便安全的传输，传输层会通过TCP三次握手建立TCP/IP链接<br>建立连接后 网络层 IP协议会查询服务器 MAC地址 也就是物理地址进行数据包的传输<br>找到对方的 MAC地址 后，将数据发送到 数据链路层传输，到此客户端发送请求阶段结束<br>接收端的服务器在 数据链路层 接收到数据包，再通过相反的方式将数据一层一层的还原回 应用层<br>服务器接收到客户端发送的HTTP请求后，会查找客户端请求的资源，并返回响应报文<br>请求成功后，服务器会返回相应的网页，浏览器接收到响应成功的报文后便开始下载网页，至此，网络通信结束<br>浏览器拿到网页文件后，首先根据顶部定义的DTD类型进行对应解析方式，网页解析会交给内部GUI渲染线程处理<br>接着构建DOM树和CSSOM树，过程中，如果遇到节点是 JS ，就会调用 JS引擎 对 JS代码进行解释执行，此时由于 JS引擎 和 GUI渲染线程 互斥，GUI渲染线程 会被挂起，渲染过程停止，如果 JS 代码的运行中对DOM树进行了修改，那么DOM构建要从新开始，然后DOM树和CSSOM树构建为渲染树<br>然后进入布局阶段，计算渲染树节点在设备视口内的确切位置和大小<br>再接着将渲染树中每个节点转换成屏幕上的实际像素，也就是绘制阶段<br>最后的合成阶段浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上<br>问：TCP/IP四、五层，OSI七层模型有什么区别？<br>网络层次可划分为 四层因特网协议栈 和 七层因特网协议栈 ，起初网络分层是标准的七层，也就是我们所说的 OSI 七层模型 ，参考模型是国际标准化组织 ISO 制定的一个用于计算机或通信系统间互联的标准体系，一般称为 OSI参考模型 或 七层模型<br>所谓的 TCP/IP 四层模型 和 TCP/IP 五层模型 是以 OSI 七层 优化而来，把某些层进行合并了，本质上还是相同的，OSI七层模型 太过细化，有一定的参考意义，但实现起来比较繁琐，相比较而言，TCP/IP模型 比较简洁，具有较强的实际应用价值<br>TCP/IP 将计算机网络分成了四个层次，一般资料或教程里都是结合 OSI7层模型 和 TCP/IP4层模型，将计算机网络按照5层的模型来讲，5层模型只是为了方便介绍计算机网络原理而设计的，而在实际应用中还是 TCP/IP四层模型<br>各层对应关系如下</p><p>问：DNS解析可优化吗，为什么优化又怎样优化？<br>是否<br>可以优化<br>为什么<br>用户打开网站的整个流程中，DNS解析是第一环，当用户输入域名并敲回车后，系统调用 DNS客户端，寻找到用户配置或者自动分配的DNS IP，之后就开始整个解析过程，DNS服务器 完成解析到此域名的 数字IP服务器，一般情况下返回给定域名对应的IP地址会花费 20<del>120毫秒 的时间，而且在这个过程中浏览器什么都不会做直到DNS查询完毕<br>一旦解析完成，连接建立并保持，也就是顺利的访问以后，网页以后的下载速度就和DNS没关系了，直到下一次重新解析和发起访问请求<br>很多小型网站，DNS解析时间都接近 0.5s，有些甚至需要 1s 左右才可以解析出结果，一般网站用户的等待时间超过 8s 就会放弃访问，而对于电子商务网站，4s 就是用户忍耐极限，而一般经过优化的小型网站，DNS解析时间都可以控制在 200ms 左右，而带宽在 100M 左右的网站，经过优化，DNS解析时间可以控制在 50</del>100ms ，所以DNS优化还是很有必要的<br>怎样<br>DNS解析优化-善用缓存之TTL<br>DNS存在着多级缓存，每次找这么多级，很定耗时间，我们要尽量多的让用户直接从运营商的DNS缓存中拿到解析记录，这样就不需要走根域名服务器以下的这些过程，自然就节省了一些时间<br>购买域名做域名解析时，有一个 TTL 值，它指的是域名解析的生命周期 ( 秒为单位 )，简单来说它表示DNS服务器解析域名时记录在DNS服务器上的缓存时间，这个值的大小设置也是很有学问的，我们要在尽可能快的情况下又要保证当服务器出问题时能够尽快切换</p><p>我们自己肯定清楚自己的服务器有没有多台或备份，若无备份，那服务器宕机时只能生抗，所以，TTL 时间对于你来说是越长越好，因为 TTL 短的目的是服务器发生问题时，可以及时切换，这个对于没有备份的网站基本利用不上，所以这时你的 TTL 设置就越长越好，当然了，也不能太长，一般设置 TTL 3600 即可<br>若有备份或多台服务器，会发生由于服务器宕机需要及时做切换，TTL 时间越短切换越及时，但是 TTL 时间越短，也就意味着运营商DNS经常缓存不住，一般用户，设置为 TTL 600 即可，如果对及时切换，要求特别苛刻的网站，设置 TTL 120 就行</p><p>DNS解析优化-负载均衡<br>在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的，可以根据每台机器的负载量或该机器离用户地理位置的距离入手<br>就像我们使用CDN厂商做域名解析，它也是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容，CDN厂商的域名解析服务器用户量多被访问的次数也多，域名解析服务器的A记录基本上会被各地运营商的DNS一直缓存着，所以服务效果也是最好的<br>问：TCP/IP协议与UDP协议优缺点及区别？<br>首先请注意，这题目本身就是一个坑<br>TCP/IP协议 是一个协议簇，它包括很多协议，UDP协议 只是其中的一个，之所以命名为 TCP/IP协议，是因为TCP和IP协议是两个很重要的协议，就用它两命名了，仅此而已，SO，这个题目是不正确的，正确的问法应该是TCP协议和UDP协议优缺点及区别<br>你可能会说有面试官这样问吗？别说这抠字眼的题，还真有人因为忽略了这点被安排过 😄<br>问：TCP协议和UDP协议优缺点及区别？<br>优缺点<br>TCP 的优点： 稳定可靠， 这体现在TCP传递数据之前，会有三次握手来建立连接，且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约一些系统资源<br>TCP的缺点：占用系统资源高，慢且效率低，TCP在传递数据之前，要先建连接，会消耗时间，在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，每个连接都会占用系统的CPU、内存等硬件资源<br>UDP 的优点： 快，UDP是一个无状态的传输协议，所以它在传递数据时非常快<br>UDP 的缺点： 不可靠，不稳定，因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包<br>一般当我们对网络通讯质量有要求的时候，就应该使用TCP，要把整个数据准确无误的传递给对方，比如HTTP、HTTPS、FTP等协议，当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP，如语音，视频等<br>区别</p><p>TCP协议基于连接UDP协议无连接</p><p>TCP协议面向字节流，简单说TCP把数据看成一连串无结构的字节流而UDP协议面向报文</p><p>TCP协议传送数据，无差错不丢失不重复，且按序到达，UDP不保证可靠交付和顺序，可能丢包</p><p>TCP首部开销20字节，UDP的首部开销较小，只有8个字节</p><p>TCP协议连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信</p><p>问：简单介绍下TCP三次握手四次挥手？<br>三次握手 ( 网图侵删 )</p><p>PS: 请认真看图并配合下面文字理解<br>开始时，双端处于 CLOSE (关闭状态)，服务端要提供服务，会主动监听某个端口，进入 LISTEN (监听状态)<br>客户端主动发送连接的SYN包，之后进入 SYN-SENT (同步已发送状态)<br>服务端在收到客户端发来的SYN包后，回复SYN/ACK包，之后进入 SYN-RCVD (同步收到状态)<br>客户端收到服务端发来的SYN/ACK包后，确认对方后回复ACK包，并进入 ESTABLISHED (已建立连接状态)<br>当服务器收到客户端的确认后也进入 ESTABLISHED (已建立连接状态) ，此后双方就可以开始通信了<br>四次挥手 ( 网图侵删 )</p><p>PS: 请认真看图并配合下面文字理解<br>开始时双端还都处于 ESTABLISHED (已建立连接状态) 并传输数据，某一端可以主动发起 FIN 包准备断开连接，上图为客户端发起 FIN 请求，在发出FIN后，客户端进入 FIN-WAIT-1 (终止等待状态1)<br>服务端收到 FIN 消息后，回复 ACK 表示知道了，并从ESTABLISHED (已建立连接状态)进入 CLOSED-WAIT (关闭等待状态)，开始做一些断开连接前的准备工作<br>客户端收到之前FIN的回复 ACK 消息后，进入 FIN-WAIT-2 (终止等待状态2)，当服务端做好断开前的准备工作后，也会发送一个 FIN/ACK 的消息給客户端，表示我也好了，请求断开连接，并在发送消息后，服务端进入 LAST-ACK (最后确认状态)<br>客户端在收到 FIN/ACK 消息后，会立即回复 ACK ，表示知道了，并进入 TIME_WAIT ( 时间等待状态)，为了稳定和安全考虑，客户端会在 TIME-WAIT ( 时间等待状态) 等待 2MSL ( 最长报文段寿命 ) 的时长，最终进入 CLOSED ( 关闭状态 )<br>服务端收到客户端回复的 ACK 消息后，直接从 LAST-ACK (最后确认状态) 状态进入 CLOSED ( 关闭状态 )<br>四次挥手之后，双端都进入 CLOSED ( 关闭状态 )，在此之后，双端正式断开了连接<br>PS:  MSL ( Maximum Segment Lifetime ) 为 最长报文段寿命，它指的是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，TCP允许不同的实现可以设置不同的 MSL 值<br>问：为什么建立连接是三次握手，关闭连接确是四次挥手？<br>建立连接的时候， 服务器在  LISTEN (监听状态) ，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端就可以了<br>而关闭连接时，服务器收到对方的 FIN 报文时，仅代表对方不再发送数据了但是还能接收数据，而自己未必全部数据都发送给对方了，所以自己可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次<br>问：为什么要三次握手创建链接，最后一次确认有必要吗？<br>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误<br>如果使用两次握手建立连接，假如客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，然后客户端和服务器经过两次握手完成连接，传输数据后关闭连接，此时之前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手机制就会让客户端和服务器再次建立连接，会导致不必要的错误和资源的浪费<br>采用三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认，由于服务器收不到确认，就会知道客户端并没有请求连接<br>为什么不用四次握手就更简单了，三次就可以创建安全无误的连接为什么用四次，那不是浪费资源嘛<br>问：三次握手过程中可以携带数据吗？<br>第一次、第二次握手不可以携带数据，因为一握二握时还没有建立连接，会让服务器容易受到攻击<br>而第三次握手，此时客户端已经处于 ESTABLISHED (已建立连接状态) ，对于客户端来说，已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也是没问题的<br>问：四次挥手为什么客户端最后还要等待2MSL？<br>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器<br>第二，比如上面提到了的 已经失效的连接请求报文段 出现在连接中这种状况，客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样新连接中就不会出现旧连接的请求报文<br>问：如果已经建立了连接，但客户端突然故障怎么办？<br>TCP 还设有一个保活计时器，客户端如果出现故障，服务器总不能一直等下去，白白浪费资源啊，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时<br>若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，然后每隔75秒就会再发送一次，10次探测报文后仍然没反应的话，服务器就认为客户端出了故障，接着就关闭连接<br>问：HTTP 的请求方法？<br>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法<br>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</p><p>序号<br>方法<br>描述</p><p>1<br>GET<br>请求指定的页面信息，并返回实体主体</p><p>2<br>HEAD<br>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</p><p>3<br>POST<br>向指定资源提交数据进行处理请求 ( 例如提交表单或者上传文件 )，数据被包含在请求体中，POST 请求可能会导致新的资源的建立和/或已有资源的修改</p><p>4<br>PUT<br>从客户端向服务器传送的数据取代指定的文档的内容</p><p>5<br>DELETE<br>请求服务器删除指定的页面</p><p>6<br>CONNECT<br>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</p><p>7<br>OPTIONS<br>允许客户端查看服务器的性能</p><p>8<br>TRACE<br>回显服务器收到的请求，主要用于测试或诊断</p><p>9<br>PATCH<br>是对 PUT 方法的补充，用来对已知资源进行局部更新</p><p>问：HTTP 状态码分别代表什么？<br>状态码有五类分别代表</p><p>1xx: 协议处理中状态，还需后续操作<br>2xx: 成功状态<br>3xx: 重定向状态，资源位置发生变动，需要重新请求<br>4xx: 请求报文有误<br>5xx: 服务器端错误</p><p>详细状态码就不啰嗦了，直接 copy 菜鸟教程了一份，看一看吧，心中有个印象</p><p>状态码<br>英文名称<br>描述</p><p>100<br>Continue<br>继续。客户端应继续其请求</p><p>101<br>Switching Protocols<br>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</p><p>200<br>OK<br>请求成功。一般用于GET与POST请求</p><p>201<br>Created<br>已创建。成功请求并创建了新的资源</p><p>202<br>Accepted<br>已接受。已经接受请求，但未处理完成</p><p>203<br>Non-Authoritative Information<br>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</p><p>204<br>No Content<br>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p><p>205<br>Reset Content<br>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</p><p>206<br>Partial Content<br>部分内容。服务器成功处理了部分GET请求</p><p>300<br>Multiple Choices<br>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p><p>301<br>Moved Permanently<br>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p><p>302<br>Found<br>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p><p>303<br>See Other<br>查看其它地址。与301类似。使用GET和POST请求查看</p><p>304<br>Not Modified<br>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p><p>305<br>Use Proxy<br>使用代理。所请求的资源必须通过代理访问</p><p>306<br>Unused<br>已经被废弃的HTTP状态码</p><p>307<br>Temporary Redirect<br>临时重定向。与302类似。使用GET请求重定向</p><p>400<br>Bad Request<br>客户端请求的语法错误，服务器无法理解</p><p>401<br>Unauthorized<br>请求要求用户的身份认证</p><p>402<br>Payment Required<br>保留，将来使用</p><p>403<br>Forbidden<br>服务器理解请求客户端的请求，但是拒绝执行此请求</p><p>404<br>Not Found<br>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p><p>405<br>Method Not Allowed<br>客户端请求中的方法被禁止</p><p>406<br>Not Acceptable<br>服务器无法根据客户端请求的内容特性完成请求</p><p>407<br>Proxy Authentication Required<br>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</p><p>408<br>Request Time-out<br>服务器等待客户端发送的请求时间过长，超时</p><p>409<br>Conflict<br>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</p><p>410<br>Gone<br>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</p><p>411<br>Length Required<br>服务器无法处理客户端发送的不带Content-Length的请求信息</p><p>412<br>Precondition Failed<br>客户端请求信息的先决条件错误</p><p>413<br>Request Entity Too Large<br>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</p><p>414<br>Request-URI Too Large<br>请求的URI过长（URI通常为网址），服务器无法处理</p><p>415<br>Unsupported Media Type<br>服务器无法处理请求附带的媒体格式</p><p>416<br>Requested range not satisfiable<br>客户端请求的范围无效</p><p>417<br>Expectation Failed<br>服务器无法满足Expect的请求头信息</p><p>500<br>Internal Server Error<br>服务器内部错误，无法完成请求</p><p>501<br>Not Implemented<br>服务器不支持请求的功能，无法完成请求</p><p>502<br>Bad Gateway<br>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</p><p>503<br>Service Unavailable<br>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</p><p>504<br>Gateway Time-out<br>充当网关或代理的服务器，未及时从远端服务器获取请求</p><p>505<br>HTTP Version not supported<br>服务器不支持请求的HTTP协议的版本，无法完成处理</p><p>问：HTTP与HTTPS的区别？<br>HTTP协议传输的数据都是未加密的，也就是明文的，所以使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer） 协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS<br>简单来说，HTTPS协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，更多HTTP和HTTPS内容请自行百度，这里就不长篇大论了<br>那么简单总结下有区别</p><p>HTTPS协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用</p><p>HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议</p><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</p><p>HTTP的连接很简单，是无状态的，HTTPS协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全</p><p>问：什么是简单请求和非简单请求？<br>CORS（cross-origin resource sharing），跨源资源共享，就是广大前端同学所说的跨域，想必大家都了解，不了解这也不做介绍了，不了解可以看 HTTP访问控制（CORS）- MDN传送门  😄<br>CORS中把请求定义为了两类</p><p>简单请求<br>非简单请求</p><p>那么什么是简单请求什么是非简单请求呢？其实也很简单，我们只需要知道什么是简单请求，其余的就都是非简单的了，而简单请求需要满足的条件是</p><p>请求方式只能是GET、POST、HEAD三种<br>HTTP头部信息不超过一下几种字段</p><p>无自定义头部字段<br>Accept、Accept-Language、Content-Language、Last-Event-ID<br>Content-Type只有三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</p><p>简单请求需要满足上面的条件，其实平常也就是传统的表单请求了，看了上面的简单请求条件，那么非简单请求是不是就呼之欲出了呢，比如下面这些只要满足一个就是非简单请求</p><p>请求方式是PUT、DELETE</p><p>自定义头部字段</p><p>发送JSON格式数据等等</p><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，请求方式为 OPTIONS，称为 预检请求 (preflight)<br>浏览器会先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段，得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就会报错，这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，防止服务器收到大量 DELETE 和 PUT请求，这些传统的表单不可能跨域发出的请求<br>问：CSS 资源加载会阻塞渲染怎样优化？<br>优化DOM树，DOM尽可能的小<br>CSS尽量用 id 和 class 少直接用标签，因为标签节点样式是可以继承的，所以在构建的过程中浏览器得递归 DOM 树来确定元素到底是什么样式<br>对于首屏渲染需要用到的CSS代码加入Inline CSS ( 内联样式 )<br>对于首屏渲染不需要用到的CSS，可以使用文件形式并在页面内容渲染完成后再加载<br>问：什么是回流和重绘以及区别？<br>要知道，生成DOM树时是包括 display:none 的节点的，DOM树和CSSOM树的基础上根据节点的集合属性 margin/padding/width/height等 生成渲染树 ( render ) ，渲染树不包括 display:none 的节点和 head 等节点，但是包括 visibility:hidden 的节点<br>当渲染树节点因为大小边距等问题发生改变而需要重建的过程，叫做 回流 (Reflow)<br>元素发生的改变只是影响了元素的一些外观之类的时候 ( 例如，背景色，边框颜色，文字颜色等 )，此时只需要应用新样式绘制这个元素就可以了，称之为 重绘 (Repaint)<br>回流必将引起重绘，而重绘不一定会引起回流，很明显 回流 代价较大<br>问：什么会引起回流？</p><p>页面渲染初始化</p><p>DOM结构改变，比如删除了某个节点</p><p>render树变化，比如减少了 padding ( 内边距 )</p><p>窗口 resize 事件触发时</p><p>某些 JS 属性，引发回流，很多浏览器会对回流做优化，等到数量足够时做一次批处理回流， 但除了 render树 的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效</p><p>offset ( Top/Left/Width/Height )<br>scroll ( Top/Left/Width/Height )<br>cilent ( Top/Left/Width/Height )<br>width, height<br>调用了 getComputedStyle() 或者IE的 currentStyle</p><p>问：如何减少和避免回流重绘？<br>减少逐项更改样式，最好一次性更改 style，或者将样式定义为 class 并一次性更新<br>避免循环操作DOM，让DOM离线后再修改</p><p>创建一个 documentFragment ，在它上面应用所有DOM操作，最后再把它添加到 window.document<br>先把DOM节点 display:none ( 会触发一次 reflow)，然后做修改后，再把它显示出来<br>克隆一个DOM节点在内存里，修改之后，与在线的节点相替换</p><p>避免多次读取offset等属性，无法避免则将它们缓存到变量<br>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高<br>改变字体大小也会引发回流，所以尽可能减少这种操作<br>table布局，一个小改动会造成整个table的重新布局，所以，少用为好<br>问：你了解普通图层和复合图层吗？<br>浏览器渲染的图层一般包含两大类：普通图层 以及 复合图层<br>普通文档流可以理解为一个复合图层，我们叫它默认复合层，因为里面不管添加多少元素，其实都是在同一个复合图层中，absolute 布局、 fixed 也一样，虽然可以脱离普通文档流，但它仍然属于 默认复合层<br>复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，从而提升性能，但也不能大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡，因小失大<br>GPU中，各个复合图层是单独绘制的，所以也互不影响，通过 硬件加速 的方式，会声明一个 新的复合图层 ，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响 默认复合层 里的回流重绘<br>PS： 硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页<br>问：浏览器页面渲染优化？</p><p>HTML文档结构层次尽量少，最好不深于六层</p><p>JS 脚本尽量后放</p><p>样式结构层次尽量简单</p><p>少量首屏样式使用内联方式放在标签内</p><p>在脚本中尽量减少DOM操作，尽量访问离线DOM样式信息，避免过度触发回流</p><p>减少通过 JS 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画</p><p>尽量减少浏览器重排和重绘的一些情况发生</p><p>2020年了！就不要使用 table 布局了</p><p>CSS 动画中尽量只使用 transform 和 opacity ，不会发生重排和重绘</p><p>隐藏在屏幕外，或在页面滚动时，尽量停止动画</p><p>尽可能只使用 CSS 做动画，CSS动画肯定比 JS 动画要好很多</p><p>避免浏览器的隐式合成</p><p>改变复合层的尺寸</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此文是一道面试题，又不仅仅是一道面试题，你会发现，这题不论大厂小厂，都会问，为什么&lt;br&gt;因为它足够经典，连续写了三篇帖子，每篇都上万字，依然感觉不够细，涉及的点真的很考验一个人的知识覆盖率，还是多方面的考验，如果让我来面试的话，我觉得完全可以通过这一道题挖掘出面试者的基础</summary>
      
    
    
    
    
    <category term="转载" scheme="http://havebear.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的面试题 - HTTP 篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTTP%20%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTTP%20%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.131Z</published>
    <updated>2025-07-18T06:03:17.131Z</updated>
    
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的前端面试题 - 工程化篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.131Z</published>
    <updated>2025-07-18T06:03:17.131Z</updated>
    
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的面试题 - HTTP 篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.131Z</published>
    <updated>2025-07-18T06:03:17.132Z</updated>
    
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的前端面试题 - Vue3 篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue2%20%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue2%20%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.130Z</published>
    <updated>2025-07-18T06:03:17.130Z</updated>
    
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的前端面试题 - Vue3 篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue3%20%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue3%20%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.130Z</published>
    <updated>2025-07-18T06:03:17.131Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="谈谈对-MVVM-的理解"><a href="#谈谈对-MVVM-的理解" class="headerlink" title="谈谈对 MVVM 的理解"></a>谈谈对 MVVM 的理解</h2><p>MVVM 是 Model-View-ViewModel 的锁鞋，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 代表数据模型，View 代表 UI 组件，ViewModel 是 VIew 和 Model 的桥梁，数据会绑定到 ViewModel 上，并自动将数据渲染到页面中，视图变化的时候会通知 ViewModel 更新数据。</p><h2 id="Vue3-对比-Vue2-有哪些优势"><a href="#Vue3-对比-Vue2-有哪些优势" class="headerlink" title="Vue3 对比 Vue2 有哪些优势"></a>Vue3 对比 Vue2 有哪些优势</h2><p>性能更好，打包体积更小，更好的 ts 支持，更好的代码组织，更好的逻辑抽离，更多的新功能</p><h2 id="Vue3-的新特性"><a href="#Vue3-的新特性" class="headerlink" title="Vue3 的新特性"></a>Vue3 的新特性</h2><ul><li>性能提升<ul><li>响应式性能提升，由原来的 <code>Object.defineProperty</code> 改为 <code>ES6</code> 的 Proxy，速度更快</li><li>重写了 <code>Vdom</code>，diff 算法优化，增加了静态标记</li><li>进行了模板编译优化，静态提升，不参与更新的元素只被创建一次</li><li>更高效的组件初始化</li></ul></li><li>更好的支持 TypeScript<ul><li>Vue2 选用 Flow 做类型检查来避免一些因类型问题导致的错误，但是 Flow 对于一些复杂场景类型的检查，支持得并不好</li><li>Vue3 抛弃了 Flow，使用 TypeScript 重构了整个项目</li><li>TypeScript 提供了更好的类型检查，能支持复杂的类型推断</li></ul></li><li>新增 Composition API<ul><li>提高代码逻辑的复用性和维护性，同时代码压缩性更强</li><li>定义 methods、watch、computed、data 都放在了 setup() 函数中</li><li>setup() 函数会在 created() 之前执行，beforeCreate &gt; setup &gt; cteated</li></ul></li><li>新增组件<ul><li>Fragment 不再限制 template 只有一个根节点</li><li>Teleport 传送门，允许我们将控制的内容传送到任意 DOM中，就是指定组件挂载位置，如通过 #id</li><li>Suspense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验</li></ul></li><li>Tree-shaking，支持摇树优化<br>会将不需要的模块修剪掉，打包真正需要的模块，优化后的项目体积只有原来的一般，加载速度会更快。</li><li>Custom Renderer API，自定义渲染器<br>实现 DOM 的方式进行 WebGL 编程</li></ul><h2 id="Vue3-和-Vue2-的区别"><a href="#Vue3-和-Vue2-的区别" class="headerlink" title="Vue3 和 Vue2 的区别"></a>Vue3 和 Vue2 的区别</h2><ul><li>源码组织方式变化，使用 TypeScript 重写</li><li>支持 Compsition API，基于函数的 API，更加灵活地组织组件逻辑（Vue2 是 Options API）</li><li>响应式系统提升，从 defineProperty 到 Proxy，可监听动态新增删除属性以及数组的变化</li><li>编译优化，Vue2 通过标记静态根节点优化 diff，Vue3 标记和提升所有静态根节点，diff 的时候只需要对比动态节点内容</li><li>打包体积优化，移除了不常用的 API（inline-template、filter）</li><li>生命周期的变化，使用 setup 代替了之前的 beforeCreate 和 created</li><li>Vue3 的 template 模板支持多个根标签</li><li>更多</li></ul><h2 id="Vue3-性能提升主要是通过哪些方面体现的"><a href="#Vue3-性能提升主要是通过哪些方面体现的" class="headerlink" title="Vue3 性能提升主要是通过哪些方面体现的"></a>Vue3 性能提升主要是通过哪些方面体现的</h2><ul><li><strong>编译阶段优化</strong><br>回顾 Vue2，我们知道每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据 property 记录为依赖，当依赖发生变化，触发 setter，则会通知 watcher，从而使关联的组件重新渲染，因此，Vue3 在编译阶段做了进一步的优化：<ul><li><strong>diff 算法优化</strong><br>增加了静态标记，其作用是为了在发生变化的地方添加一个 flag 标记，下次发生变化时直接在该处进行比较。</li><li><strong>静态提升</strong><br>Vue3 对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接服用。避免了重复的创建操作，优化内存。</li><li><strong>事件监听缓存</strong><br>默认情况下绑定事件行为会被视为动态绑定（未开启事件监听器缓存），所以每次都会追踪它的变化，开启事件侦听器缓存后，没有了静态标记，下次 diff 算法的时候直接使用。</li><li><strong>SSR 优化</strong><br>当静态内容大到一定量级的时候，会用 createStaticVNode 方法在客户端生成一个 static node，这些静态 node会被直接 innerHTML，就不需要创建对象，然后根据对象渲染</li></ul></li><li><strong>源码体积</strong><br>相比 Vue2，Vue3 整体体积变小了，移除了一些不常用的 API，最重要的是增加了 Treeshaking，任何一个函数，如 ref、reactive、computed 等，仅仅在用到的时候才打包，没用到的模块会被移除，减小体积。</li><li><strong>响应式系统</strong><br>Vue2 采用 defineProperty 来实现数据劫持，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter 实现响应式。<br>Vue3 采用 Proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听，不需要深度遍历，另外还解决了 2 中的不足：<ul><li>可以监听动态属性的添加</li><li>可以监听数组的索引和数组的 length 属性</li><li>可以监听删除属性</li></ul></li></ul><h2 id="Vue3-的响应式原理"><a href="#Vue3-的响应式原理" class="headerlink" title="Vue3 的响应式原理"></a>Vue3 的响应式原理</h2><h3 id="Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢"><a href="#Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢" class="headerlink" title="Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢?"></a>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢?</h3><p>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。</p><h3 id="监测数组的时候可能触发多次get-set，那么如何防止触发多次呢？"><a href="#监测数组的时候可能触发多次get-set，那么如何防止触发多次呢？" class="headerlink" title="监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？"></a>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</h3><p>我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><h2 id="v-model-双向绑定的原理是什么"><a href="#v-model-双向绑定的原理是什么" class="headerlink" title="v-model 双向绑定的原理是什么"></a>v-model 双向绑定的原理是什么</h2><p>v-model 本质上是一个语法糖，可以看成是 value + input 方法的组合。可以通过 model 属性的 prop 和 event 属性来进行自定义。原生的 v-model 会根据标签的不同生成不同的事件和属性。</p><h2 id="Options-API-的生命周期"><a href="#Options-API-的生命周期" class="headerlink" title="Options API 的生命周期"></a>Options API 的生命周期</h2><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>onMounted</li><li>beforeUpdate</li><li>onUpdated</li><li>beforeUnmount</li><li>onUnmounted</li><li>onActivated</li><li>onDeactivated</li><li>onErrorCaptured</li></ul><h2 id="Composition-API-和-Options-API"><a href="#Composition-API-和-Options-API" class="headerlink" title="Composition API 和 Options API"></a>Composition API 和 Options API</h2><p>Options API 是一种基于对象的 API，用组件的选项（data、computed、methods、watch）组织逻辑在大多数情况下是可行的，然后当组件变得复杂，导致对应属性的列表也会增加，可能会导致组件难以理解和阅读。</p><p>Composition API 是一种函数式的 API，组件根据逻辑功能来组织，一个功能定义的所有 API 会放在一起（更加的 高内聚、低耦合）</p><p>Composition API 相对于 Options API 有以下优点：</p><ul><li>逻辑组织<ul><li>Options API 在处理大型组件时，内部逻辑点容易碎片化，可能同时存在于各选项中（data、computed、methods、watch），我们必须不断地“跳转”相关代码的选项块，这种碎片化使得理解和维护复杂组件变得困难。</li><li>Composition API 把某个逻辑相关代码全部放在一个函数里。</li></ul></li><li>逻辑复用<br>在 Vue2 中，使用混入函数 mixin 会存在两个非常明显的问题，命名冲突和数据来源不清晰，而 Composition API 可以通过编写多个 hooks 函数来实现逻辑复用。</li></ul><h2 id="reactive、ref-、toRef-和-toRefs"><a href="#reactive、ref-、toRef-和-toRefs" class="headerlink" title="reactive、ref 、toRef 和 toRefs"></a>reactive、ref 、toRef 和 toRefs</h2><ul><li>ref，函数可以接受基本数据类型和引用数据类型，创建的响应式数据在模板中可以直接使用，在 JavaScript 中使用需要通过 .value 的形式。</li><li>reactive，函数只能接受引用数据类型。</li><li>toRef，函数可以把响应式对象中的某个属性转换成 ref 对象。</li><li>toRefs，将一个响应式对象转为普通对象，对象的每一个属性都转换成 ref 对象。</li></ul><h2 id="script-setup"><a href="#script-setup" class="headerlink" title="script setup"></a>script setup</h2><p>Vue3 的语法糖，简化了组合式 API 的写法</p><ul><li>属性和方法无需返回，可直接使用</li><li>引入的组件会自动注册，无需通过 components 手动注册</li><li>使用 defineProps 接收父组件传递的值</li><li>useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件</li><li>默认不会对外暴露任何属性，如果有需要可使用 definExpose</li></ul><h3 id="在-setup-中如何获取组件实例"><a href="#在-setup-中如何获取组件实例" class="headerlink" title="在 setup 中如何获取组件实例"></a>在 setup 中如何获取组件实例</h3><p>使用 getCurrentInstance() 方法来获取组件实例，该方法返回一个对象，对象包含了组件实例及其相关信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="title function_">getCurrentInstance</span>()</span><br></pre></td></tr></table></figure><h2 id="v-if-和-v-for-的优先级"><a href="#v-if-和-v-for-的优先级" class="headerlink" title="v-if 和 v-for 的优先级"></a>v-if 和 v-for 的优先级</h2><p>在 Vue2 中 v-for 优先级更高，但在 Vue3 中 v-if 优先级更高。</p><h2 id="watch-和-watchEffect"><a href="#watch-和-watchEffect" class="headerlink" title="watch 和 watchEffect"></a>watch 和 watchEffect</h2><p>watch 和 watchEffect 都是监听器，watchEffect 是一个副作用函数，它们之间的区别：</p><ul><li>watch 需要指定监视的数据源和回调函数，watchEffect，不需要指定监视的数据源，它会自动追踪响应式数据的变化，回调函数中用到了哪个数据，就监视哪个数据</li><li>watch 可以访问到旧值和新值，watchEffect 只能访问到新值</li><li>watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 会立即执行一次，这一点通过 watch 的配置项 immediate 可以改变</li><li>watchEffect 有点像 computed<ul><li>但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值</li><li>而 watchEffect 注重的是过程（回调函数的执行），所以不用写返回值</li></ul></li><li>watch 与 Vue2 中的 watch 配置功能一致，但需要注意<ul><li>监视 reactive 定义的响应式数据时，oldValue 无法正确获取，且会强制开启深度检测（deep 配置失效）</li><li>监视 reactive 定义的响应式数据中某个属性时，deep 配置有效</li></ul></li></ul><h2 id="Vue2-Vue3-组件通信方式"><a href="#Vue2-Vue3-组件通信方式" class="headerlink" title="Vue2/Vue3 组件通信方式"></a>Vue2/Vue3 组件通信方式</h2><p>Vue3 通信方式</p><ul><li>props</li><li>$emit</li><li>expose/ref</li><li>$attrs</li><li>v-model</li><li>provide/inject</li><li>Vuex/pinia</li><li>mitt</li></ul><p>Vue2 通信方式</p><ul><li>props</li><li>$emit/v-on</li><li>.sync</li><li>v-model</li><li>ref</li><li>children/parent</li><li>attrs/listeners</li><li>provide/inject</li><li>eventBus</li><li>Vuex</li><li>$root</li><li>slot</li></ul><!-- # 收集的前端面试题 - Vue3 篇## Vue3 有什么更新- 响应式系统  - Proxy 代替 Object.defineProperty  - 基于 ES6 Map 代替 Object  - 基于 ES6 Set 代替 Array  - 基于 ES6 WeakMap 代替 Object  - 基于 ES6 WeakSet 代替 Array --><ul><li>Vue 的生命周期有哪些，以及每个生命周期做了什么</li><li>Vue 的响应式原理是什么，Vue3 中是如何实现的</li><li>Vue3 和 Vue2 有什么区别</li><li>谈谈对 MVVM 的理解</li><li>在 Vue2 中如何检测数据的变化</li><li>v-model 双向绑定的原理是什么</li><li>Vue2 和 Vue3 渲染器的 diff 算法分别说一下</li><li>Vue2/3 组件通信方式</li><li>Vue 的路由实现，hash 和 history 路由实现原理</li><li>说一下 v-if 和 v-show 的区别</li><li>keep-alive 的常用属性和实现原理</li><li>nextTick 的作用是什么，实现原理是什么</li><li>说一下 Vue SSR 的实现原理</li><li>Vue 组件的 data 为什么必须是函数</li><li>说一下 Vue 的 computed 的实现原理</li><li>说一下 Vue complier 的实现原理</li><li>Vue 和 React 的区别</li><li>说一下 watch 与 computed 的区别是什么，以及对应的使用场景</li><li>Vue 有哪些修饰符</li><li>如何实现 Vue 项目的性能优化</li><li>Vue 中的 SPA 应用如何优化首屏加载速度</li><li>Vue 中的 key 的作用是什么</li><li>你的接口请求一般放在哪个生命周期中？为什么</li><li>Vue3 对比 Vue2 有什么优势</li><li>描述 Vue3 的生命周期</li><li>如何看待 Composition API 和 Options API</li><li>Vue3 有什么更新</li><li>Proxy 和 Object.defineProperty 的区别</li><li>Vue3 升级了哪些重要功能</li><li>Vue2 和 Vue3 核心 diff 算法区别</li><li>Vue3 为什么比 Vue2 快</li><li>Vue3 如何实现响应式</li><li>Vue3 编译做了哪些优化</li><li>watch 和 watchEffect 的区别</li><li>请介绍 Vue3 中的 Teleport（瞬移） 组件，是什么以及使用场景</li><li>如何理解 reactive、ref、toRef 和 toRefs</li><li>谈谈 pinia</li><li>EventBus 和 mitt 的区别</li><li>script setup 是什么</li><li>v-if 和 v-for 的优先级</li><li>setup 中如何获取组件实例</li><li>Vue3 中的 Suspense 是什么，如何是用它来处理异步组件</li><li>Vue3 性能提升主要是通过什么方面体现的</li><li>Vue3 为什么要用 Proxy API 替代 defineProperty API</li><li>Vue3 中的 Treeshaking 特性</li><li>说说你对 SPA 单页面的理解，它的优缺点分别是什么</li><li>v-show 与 v-if 有什么区别</li><li>Class 与 Style 如何动态绑定</li><li>怎么理解 Vue 的单向数据流</li><li>computed 和 watch 的区别和运用的场景</li><li>直接给一个数组项赋值，Vue 能检测到变化吗</li><li>谈谈你对 Vue 生命周期的理解</li><li>Vue 的父组件和子组件生命周期钩子函数执行顺序</li><li>在哪个生命周期内调用异步请求</li><li>在什么阶段才能访问操作DOM</li><li>父组件可以监听到子组件的生命周期吗</li><li>谈谈你对 keep-alive 的了解</li><li>组件中 data 为什么是一个函数</li><li>v-model 的原理</li><li>Vue 组件间通信有哪几种方式</li><li>你使用过 Vuex 吗</li><li>使用过 Vue SSR 吗？说说 SSR</li><li>vue-router 路由模式有几种</li><li>能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</li><li>什么是 MVVM</li><li>Vue 是如何实现数据双向绑定的</li><li>Vue 框架怎么实现对象和数组的监听</li><li>Proxy 与 Object.defineProperty 优劣对比</li><li>Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</li><li>虚拟 DOM 的优缺点</li><li>虚拟 DOM 实现原理</li><li>Vue 中的 key 有什么作用</li><li>你有对 Vue 项目进行哪些优化</li><li>对于即将到来的 vue3.0 特性你有什么了解的吗</li><li>说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;谈谈对-MVVM-的理解&quot;&gt;&lt;a href=&quot;#谈谈对-MVVM-的理解&quot; class=&quot;headerlink&quot; title=&quot;谈谈对 MVVM 的理解&quot;&gt;&lt;/a&gt;谈谈对 MVVM 的理解&lt;/h2&gt;&lt;p&gt;MVVM </summary>
      
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的前端面试题 - TypeScript 篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20TypeScript%20%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20TypeScript%20%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.130Z</published>
    <updated>2025-07-18T06:03:17.130Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="什么是-TypeScript"><a href="#什么是-TypeScript" class="headerlink" title="什么是 TypeScript"></a>什么是 TypeScript</h2><p>TypeScript是一种由微软开发的开源编程语言，它是JavaScript的超集。TypeScript通过添加静态类型、类、接口和模块等功能，使得在大型应用程序中更容易进行维护和扩展。它可以被编译为纯JavaScript，从而能够在任何支持JavaScript的地方运行。使用TypeScript可以帮助开发人员在编码过程中避免一些常见的错误，并提供更好的代码编辑功能和工具支持。</p><h2 id="类型声明和类型推断的区别，并举例"><a href="#类型声明和类型推断的区别，并举例" class="headerlink" title="类型声明和类型推断的区别，并举例"></a>类型声明和类型推断的区别，并举例</h2><p>类型声明是显式地为变量或者函数指定类型，而类型推断是 TypeScript 根据赋值语句右侧的值自动推断变量类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="comment">// 类型推断</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>; <span class="comment">// 推断为 number 类型</span></span><br></pre></td></tr></table></figure><h2 id="什么是接口（interface），作用和使用场景，接口和类型别名（Type-Alias）的区别"><a href="#什么是接口（interface），作用和使用场景，接口和类型别名（Type-Alias）的区别" class="headerlink" title="什么是接口（interface），作用和使用场景，接口和类型别名（Type Alias）的区别"></a>什么是接口（interface），作用和使用场景，接口和类型别名（Type Alias）的区别</h2><p><strong>interface</strong></p><ol><li>定义对象类型，主要用于定义对象的形状，描述对象应该具有哪些属性和方法<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可扩展性，interface 可以被扩展，可以通过继承来添加更多的属性和方法<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">gender</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现接口，以确保类具有接口中定义的所有属性和方法<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>type</strong></p><ol><li>定义类型别名，可以用于定义任何类型的别名，包括基本类型、联合类型、交叉类型等。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示一个可以是字符串或数字的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumber</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure></li><li>不能被扩展。</li><li>用于复杂类型，如函数类型、元组类型等。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示一个接受一个数字参数并返回 void 的函数</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Callback</span> = <span class="function">(<span class="params"><span class="attr">arg</span>: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure></li></ol><p>interface 用于描述对象的形状，描述对象应该具有的属性和方法。在 TypeScript 中，interface 可以用来约束对象的结构，以提高代码的可读性和维护性。</p><p>总结：</p><ul><li>interface 和 type 在很多情况下可以相互替代，但在一些特定场景下，选择其中一个可能更加合适</li><li>如果主要定义对象的形状，并且可能需要扩展，那么 interface 是一个好的选择</li><li>如果需要定义复杂的类型别名，或者不需要扩展的类型，那么 type 是一个好的选择</li></ul><h2 id="什么是泛型（generics），作用和使用场景"><a href="#什么是泛型（generics），作用和使用场景" class="headerlink" title="什么是泛型（generics），作用和使用场景"></a>什么是泛型（generics），作用和使用场景</h2><p>泛型是一种参数化类型，它可以在定义时不确定具体的类型，而是在使用时才确定具体的类型。泛型可以用于函数、类、接口等，以提高代码的复用性和灵活性。例如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 调用时指定具体的类型</span></span><br></pre></td></tr></table></figure><h2 id="什么是枚举（enum），作用和使用场景，枚举和常量枚举的区别"><a href="#什么是枚举（enum），作用和使用场景，枚举和常量枚举的区别" class="headerlink" title="什么是枚举（enum），作用和使用场景，枚举和常量枚举的区别"></a>什么是枚举（enum），作用和使用场景，枚举和常量枚举的区别</h2><p>枚举（enum）是一种用于定义一组命名常量的类型，它可以提高代码的可读性和维护性。枚举是一种类型，它允许你定义一组命名常量，枚举中的每个成员都有一个名称和一个值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，定义了一个名为 Color 的枚举，它包含了三个成员：<code>Red</code>、<code>Green</code> 和 <code>Blue</code>。默认情况下，枚举成员的值从 0 开始递增，所以它们的值分别为 0、1 和 2。可以使用枚举成员来访问枚举值，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(color); <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure><p>手动分配枚举值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&quot;DOWN&quot;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&quot;RIGHT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量枚举（const enum），它是在编译阶段被完全移除的枚举，不会在生成的 JavaScript 代码中出现，而是在编译阶段被替换为相应的常量值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，定义了一个常量枚举 <code>Color</code>，在编译后的 JavaScript 代码中， color 变量将被直接赋值为 0，而不会有 <code>Color</code> 枚举的存在。</p><p>优点：</p><ul><li>常量枚举可以减少生成的 JavaScript 代码的大小，因为它们在编译时被替换它们的值</li><li>它们也可以提高代码的性能，因为在运行时不需要进行枚举的查找</li></ul><p>枚举和常量枚举：</p><ul><li><code>枚举</code>可以包含计算得出的值，而常量枚举则在编译阶段被删除，并且不能包含计算得出的值，只能包含常量成员</li><li><code>常量枚举</code>在编译后会被删除，而普通枚举会生成真实的对象。</li></ul><h2 id="介绍-TypeScript-的可选属性、只读属性和类型断言"><a href="#介绍-TypeScript-的可选属性、只读属性和类型断言" class="headerlink" title="介绍 TypeScript 的可选属性、只读属性和类型断言"></a>介绍 TypeScript 的可选属性、只读属性和类型断言</h2><ul><li>可选属性，使用 <code>?</code> 来标记一个属性可以存在，也可以不存在。</li><li>只读属性，使用 <code>readonly</code> 来标记一个属性只能在声明时赋值，不能在后续的代码中修改。</li><li>类型断言，使用 <code>as</code> 关键字来告诉编译器一个变量的类型。<br>使用场景：<ul><li>当你不确定一个变量的类型时，可以使用类型断言来告诉编译器。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">len</span>: <span class="built_in">number</span> = (str <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>; <span class="comment">// 类型断言</span></span><br></pre></td></tr></table></figure></li><li>当你需要将一个联合类型的值指定为其中的某一个类型时。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = x <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 类型断言</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>类型断言只是一种告诉编译器你认为某个值的类型的方式，但是它并不能真正改变值的类型，如果断言不正确，在运行时将导致错误。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只读属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b1</span>: <span class="title class_">Book</span> = &#123; <span class="attr">title</span>: <span class="string">&quot;TypeScript&quot;</span> &#125;;</span><br><span class="line">b1.<span class="property">title</span> = <span class="string">&quot;JavaScript&quot;</span>; <span class="comment">// 报错，只读属性不能修改</span></span><br><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">len</span>: <span class="built_in">number</span> = (str <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">length</span>; <span class="comment">// 类型断言</span></span><br></pre></td></tr></table></figure><h2 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h2><p>允许一个变量可以是多种类型中的一种，使用 <code>|</code> 来分隔不同的类型。可以让代码更加灵活和可维护，同时也可以提高类型安全性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value 可以是 string 类型或者 number 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: value | <span class="built_in">number</span></span><br></pre></td></tr></table></figure><h2 id="交叉类型（Intersection-Types）"><a href="#交叉类型（Intersection-Types）" class="headerlink" title="交叉类型（Intersection Types）"></a>交叉类型（Intersection Types）</h2><p>用于将多个类型合并为一个类型，通过使用 <code>&amp;</code> 符号实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Employee</span> = &#123; <span class="attr">salary</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// PersonEmployee 类型包含了 Person 和 Employee 类型的所有属性，即 name、age 和 salary 属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonEmployee</span> = <span class="title class_">Person</span> &amp; <span class="title class_">Employee</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">employee</span>: <span class="title class_">PersonEmployee</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">salary</span>: <span class="number">5000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接口也可以交叉：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">area</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Colorful</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ColorfulShape 类型包含了 Shape 和 Colorful 接口的所有属性，即 area() 方法和 color 属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ColorfulShape</span> = <span class="title class_">Shape</span> &amp; <span class="title class_">Colorful</span>;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>如果交叉的类型中有同名的属性，那么这些属性的类型必须是兼容的</li><li>交叉类型可以创建非常复杂的类型，但也可能导致代码的可读性降低，在使用时要确保代码的意图清晰，避免过度复杂的类型定义</li></ul><h2 id="索引类型（Index-Types）"><a href="#索引类型（Index-Types）" class="headerlink" title="索引类型（Index Types）"></a>索引类型（Index Types）</h2><p>使用场景：</p><ul><li>处理动态属性名<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">config</span>: <span class="title class_">Config</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">enableLog</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getConfig</span>(<span class="params"><span class="attr">key</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> config[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>处理 API 响应数据，当从 API 接收到的数据结构不确定时，可以使用索引类型来处理这些数据<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiResponse</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">response</span>: <span class="title class_">ApiResponse</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">salary</span>: <span class="number">5000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>创建可扩展的对象类型（可以动态添加属性的对象类型）<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ExtensibleObject</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">ExtensibleObject</span> = &#123;&#125;;</span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">obj.<span class="property">b</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="const-和-readonly-关键字"><a href="#const-和-readonly-关键字" class="headerlink" title="const 和 readonly 关键字"></a>const 和 readonly 关键字</h2><p>const</p><ol><li>用于变量声明，const 用于声明一个常量，它的值不能被重新赋值</li><li>基本类型和引用类型的区别</li></ol><ul><li>基本类型：const 声明的基本类型变量的值是不可变的，即不能被重新赋值</li><li>引用类型：const 声明的引用类型变量的引用是不可变的，即不能被重新赋值，但引用类型的属性或元素可以被修改</li></ul><p>readonly</p><ol><li>用于属性声明，readonly 用于声明类的属性或接口的属性为只读属性，即只能在对象初始化时或在构造函数中赋值，之后不能被重新赋值</li><li>数组和对象的只读性，当 readonly 用于数组或对象类型时，数组或对象本身的引用可以被重新赋值，但它们的元素或属性不能被修改（如果它们不是本身也被 readonly 修饰）</li></ol><p>使用场景：</p><ul><li>const<ul><li>当你确定一个变量的值在整个程序执行过程中都不会改变时，使用 const 声明变量。</li><li>对于简单的值类型（如数字、字符串、布尔值）和不可变的引用类型（如不可变的对象或数组），使用 const 可以提高代码的可读性和安全性。</li></ul></li><li>readonly<ul><li>在类中，当你希望某个属性在对象创建后不能被修改时，使用 readonly 修饰属性。</li><li>在接口中，当你希望某个属性在实现该接口的对象中是只读的时，使用 readonly 修饰属性。</li><li>对于需要在多个地方共享但不希望被修改的对象或数组，可以使用 readonly 修饰它们的类型，以确保它们的内容不会被意外修改。</li></ul></li></ul><h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>尽管any类型提供了灵活性，但由于它会放弃TypeScript的静态类型检查，因此滥用any类型可能会降低代码的健壮性和可维护性。当滥用any类型时，可能会导致以下后果:</p><ul><li>代码可读性下降</li><li>潜在的运行时错误</li><li>类型安全受损</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>基本类型<ul><li>number，表示数字，包含证书和浮点数</li><li>string，表示文本字符串</li><li>boolean，表示布尔值，true 和 false</li><li>null、undefined</li><li>symbol，表示唯一、不可变的值</li></ul></li><li>复合类型<ul><li>array，数组</li><li>tuple，元组</li><li>enum，枚举</li></ul></li><li>对象类型<ul><li>object，表示任意对象（除了 number、string、boolean、symbol、null、undefined 之外的类型）</li><li>interface，接口，用于描述对象的结构，可重复使用</li></ul></li><li>函数类型<ul><li>function，表示函数类型</li><li>void，表示函数没有返回值</li><li>any，表示任意类型</li></ul></li><li>高级类型<ul><li>union types，联合类型，允许一个变量可以是多种类型中的一种</li><li>intersection types，交叉类型，用于将多个类型合并为一个类型</li></ul></li></ul><h2 id="interface-给-Function-Array-Class（indexable）做声明"><a href="#interface-给-Function-Array-Class（indexable）做声明" class="headerlink" title="interface 给 Function/Array/Class（indexable）做声明"></a>interface 给 Function/Array/Class（indexable）做声明</h2><ul><li>函数<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述了一个函数类型，该函数接收两个参数并返回一个数字</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyFunction</span> &#123;</span><br><span class="line">  (<span class="attr">arg1</span>: <span class="built_in">string</span>, <span class="attr">arg2</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myAdd</span>: <span class="title class_">MyFunction</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>数组<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述了一个具有数字索引签名的字符串数组。意味着我们可以通过数字索引来访问数组元素。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">StringArray</span> = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Fred&#x27;</span>];</span><br></pre></td></tr></table></figure></li><li>类<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StringDictionary</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myDict</span>: <span class="title class_">StringDictionary</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;30&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;什么是-TypeScript&quot;&gt;&lt;a href=&quot;#什么是-TypeScript&quot; class=&quot;headerlink&quot; title=&quot;什么是 TypeScript&quot;&gt;&lt;/a&gt;什么是 TypeScript&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的前端面试题 - CSS 篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20CSS%20%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20CSS%20%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.129Z</published>
    <updated>2025-07-18T06:03:17.129Z</updated>
    
    <content type="html"><![CDATA[<p><code>CSS 世界</code></p><span id="more"></span><ul><li>CSS 选择器  ⭐<ul><li>有哪些</li><li>优先级</li></ul></li><li>CSS 单位有哪些</li><li>对盒模型的理解  ⭐</li><li>有哪些方式（CSS）可以隐藏页面元素（以及区别）</li><li>水平垂直居中的方式有哪些  ⭐</li><li>CSS 的定位方式</li><li>如何理解 z-index</li><li>如何理解层叠上下文</li><li>清除浮动有哪些方法</li><li>对 css-sprites 的理解</li><li>对媒体查询的理解</li><li>标准盒模型和怪异盒模型有什么区别</li><li>对 BFC（Block Formatting Context，块级上下文）的理解</li><li>为什么有时候用 translate 来改变位置而不是定位</li><li>伪类和伪元素的区别</li><li>对 flex 布局的理解  ⭐<ul><li>flex 是什么属性的缩写</li><li>flex: 1 是什么意思</li></ul></li><li>关于 CSS 的动画与过渡问题</li><li>说说设备像素，css像素，设备独立像素，dpr，ppi之间的区别？</li><li>link 和 @import 的区别</li><li>实现 div 高度永远是宽度的一半</li><li>CSS 实现自适应正方形、等宽高比矩形</li><li>实现两栏布局的方式</li><li>实现三列布局的方式</li><li>CSS 动画有哪些</li><li>BFC 与 IFC 区别</li><li>两个div上下排列，都设margin，有什么现象？</li><li>PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种（算工程化内容）</li></ul><h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h2><h3 id="有哪些"><a href="#有哪些" class="headerlink" title="有哪些"></a>有哪些</h3><ul><li><strong>元素选择器（Element Selector）</strong><br>选择指定元素类型的所有元素，例如p选择所有段落元素。</li><li><strong>类选择器（Class Selector）</strong><br>选择具有指定类名的元素，使用”.”符号表示，例如.class选择所有具有class为”class”的元素。</li><li><strong>ID选择器（ID Selector）</strong><br>选择具有指定id的唯一元素，使用”#”符号表示，例如#myId选择id为”myId”的元素。</li><li><strong>属性选择器（Attribute Selector）</strong><br>选择具有指定属性或属性值的元素，例如[type=”text”]选择所有type属性值为”text”的元素。</li><li><strong>后代选择器（Descendant Selector）</strong><br>选择指定元素的后代元素，使用空格分隔，例如div p选择所有div元素内部的p元素。</li><li><strong>直接子元素选择器（Child Selector）</strong><br>选择指定元素的直接子元素，使用”&gt;”符号表示，例如div &gt; p选择所有div元素的直接子元素p。</li><li><strong>伪类选择器（Pseudo-class Selector）</strong><br>选择具有特定状态或行为的元素，例如:hover选择鼠标悬停的元素。</li><li><strong>伪元素选择器（Pseudo-element Selector）</strong><br>选择元素的特定部分，例如::before选择元素的前面插入内容。</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><strong>!important &gt; 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</strong></p><p>到具体的计算层面，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p><ul><li>A 的值等于 1 的前提是存在内联样式, 否则 A = 0;</li><li>B 的值等于 ID选择器 出现的次数;</li><li>C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;</li><li>D 的值等于 标签选择器 和 伪元素 出现的总次数 。</li></ul><p>就比如下面的选择器，它不存在内联样式，所以A=0,不存在id选择器B=0,存在一个类选择器C=1,存在三个标签选择器D=3，那么最终计算结果为: { 0, 0, 1 ,3 }</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span> <span class="selector-class">.red</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这个结算方式，下面的计算结果为: { 0, 1, 0, 0 }</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的比较优先级的方式是从 A 到 D 去比较值的大小，A、B、C、D 权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。</p><p>比如第二个例子的 B 与第一个例子的B相比，1 &gt; 0,接下来就不需要比较了，第二个选择器的优先级更高。</p><h2 id="CSS-单位有哪些"><a href="#CSS-单位有哪些" class="headerlink" title="CSS 单位有哪些"></a>CSS 单位有哪些</h2><ul><li><strong>px</strong>（像素）：最常用的单位，相对于显示器屏幕的一个像素。</li><li>**%**（百分比）：相对于父元素的百分比。</li><li><strong>em</strong>：相对于当前元素的字体大小。</li><li><strong>rem</strong>：相对于根元素（html 元素）的字体大小。</li><li><strong>vw</strong>：视口宽度的百分比，1vw 等于视口宽度的 1%。</li><li><strong>vh</strong>：视口高度的百分比，`1vh 等于视口高度的 1%。</li></ul><h2 id="对盒模型的理解-⭐"><a href="#对盒模型的理解-⭐" class="headerlink" title="对盒模型的理解 ⭐"></a>对盒模型的理解 ⭐</h2><p>CSS盒模型是指在网页布局中，每个元素可以看作一个矩形的盒子，这个盒子包含了内容、内边距、边框和外边距。盒模型的组成部分包括：</p><p><img src="image.png" alt="alt text"></p><ul><li><strong>内容区域</strong>（content area）：显示元素的实际内容，比如文本、图片等。</li><li><strong>内边距</strong>（padding）：内容区域与边框之间的空白区域，可以通过padding属性进行设置。</li><li><strong>边框</strong>（border）：内边距和外边距之间的边界，可以通过border属性进行设置。</li><li><strong>外边距</strong>（margin）：边框与相邻元素之间的空白区域，可以通过margin属性进行设置。</li></ul><p>在标准的盒模型中：</p><p><img src="image-1.png" alt="alt text"></p><p>元素的宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</p><p>怪异盒模型(IE) 盒子：</p><p><img src="image-2.png" alt="alt text"></p><p>元素的宽度 = margin-left + width + margin-right</p><p>虽然现代浏览器默认使用W3C的标准盒模型，但是在不少情况下怪异盒模型更好用，于是W3C在css3中加入box-sizing。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">box</span><span class="operator">-</span>sizing<span class="operator">:</span> content<span class="operator">-</span><span class="built_in">box</span> <span class="comment">// 标准盒模型</span></span><br><span class="line"><span class="built_in">box</span><span class="operator">-</span>sizing<span class="operator">:</span> border<span class="operator">-</span><span class="built_in">box</span> <span class="comment">// 怪异盒模型</span></span><br><span class="line"><span class="built_in">box</span><span class="operator">-</span>sizing<span class="operator">:</span> padding<span class="operator">-</span><span class="built_in">box</span> <span class="comment">// 火狐的私有模型，没人用</span></span><br></pre></td></tr></table></figure><h2 id="link-和-import-的区别"><a href="#link-和-import-的区别" class="headerlink" title="link 和 @import 的区别"></a>link 和 @import 的区别</h2><ul><li>link 属于 XHTML 标签，而 @import 是 CSS 提供的。</li><li>页面被加载时，link 会同时被加载，而 @import 引用的CSS会等到页面被加载完再加载。</li><li>import 只在 IE5 以上才能识别，而 link 是 XHTML 标签，无兼容问题。</li><li>link 方式的样式权重高于 @import 的权重。</li><li>使用 DOM 控制样式时的差别。当使用 JS 控制 DOM 去改变样式的时候，只能使用 link 标签，因为 @import 不是 DOM 可以控制的。</li></ul><h2 id="为什么有时候用-translate-来改变位置而不是定位"><a href="#为什么有时候用-translate-来改变位置而不是定位" class="headerlink" title="为什么有时候用 translate 来改变位置而不是定位"></a>为什么有时候用 translate 来改变位置而不是定位</h2><p>translate()是transform的一个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。transform使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此translate()更高效，可以缩短平滑动画的绘制时间。</p><p>而translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发生这种情况。</p><p>扩展阅读：<a href="https://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/">CSS3 3D transform变换-张鑫旭</a></p><h2 id="对-flex-布局的理解"><a href="#对-flex-布局的理解" class="headerlink" title="对 flex 布局的理解"></a>对 flex 布局的理解</h2><p>web应用有不同设备尺寸和分辨率，这时需要响应式界面设计来满足复杂的布局需求，Flex弹性盒模型的优势在于开发人员只是声明布局应该具有的行为，而不需要给出具体的实现方式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对齐的场景时，就要优先考虑弹性盒布局</p><p>具体用法移步阮一峰的 <a href="%5B123%5D(http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)">flex语法</a>、<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">flex实战</a>，讲得非常通俗易懂，而且我们一两句话说不清楚。</p><h3 id="flex-是什么属性的缩写"><a href="#flex-是什么属性的缩写" class="headerlink" title="flex 是什么属性的缩写"></a>flex 是什么属性的缩写</h3><p>在 CSS 中，flex 是 flex-grow、flex-shrink 和 flex-basis三个属性的缩写。</p><ul><li>flex-grow: 定义了元素的放大比例，默认为 0，即如果存在剩余空间，也不放大。</li><li>flex-shrink: 定义了元素的缩小比例，默认为 1，即如果空间不足，该元素将缩小。</li><li>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间（main size）。它可以是一个长度值（如 200px），也可以是一个百分比（如 30%），还可以是一个关键字如 auto（表示根据自身内容大小确定）或 content（表示根据内容大小自适应）。</li></ul><h3 id="flex-1-是什么意思"><a href="#flex-1-是什么意思" class="headerlink" title="flex: 1 是什么意思"></a>flex: 1 是什么意思</h3><p><code>flex</code> 是 flex-grow、flex-shrink 和 flex-basis 的缩写。当设置 flex: 1 时，它相当于以下设置：</p><ul><li>flex-grow: 1，表示当有剩余空间时，该元素应该扩大以占据剩余空间。如果有多个元素都设置了 flex-grow: 1，它们将按照比例分配剩余空间。</li><li>flex-shrink: 1，表示当空间不足时，该元素应该缩小以适应容器。</li><li>flex-basis: 0%，表示初始大小为零，即不占用固定的空间，完全由弹性布局来决定其大小。</li></ul><h2 id="关于-CSS-的动画与过渡问题"><a href="#关于-CSS-的动画与过渡问题" class="headerlink" title="关于 CSS 的动画与过渡问题"></a>关于 CSS 的动画与过渡问题</h2><p><a href="https://www.cnblogs.com/xiaohuochai/p/5391663.html">深入理解CSS动画animation</a></p><p><a href="https://www.cnblogs.com/xiaohuochai/p/5347930.html">深入理解CSS过渡transition</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;CSS 世界&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的前端面试题 - HTML 篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTML%20%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTML%20%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.129Z</published>
    <updated>2025-07-18T06:03:17.129Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><details>  <summary>doctype（文档类型）的作用是什么？</summary>  TEST</details><details>  <summary>这三种模式的区别是什么？</summary>  TEST</details><details>  <summary>HTML、XML和XHTML有什么区别？</summary>  TEST</details><details>  <summary>什么是data-*属性？</summary>  TEST</details><details>  <summary>对HTML语义化的理解</summary>  TEST</details><details>  <summary>HTML5与HTML4的区别</summary>  TEST</details><details>  <summary>有哪些常用的meta标签</summary>  TEST</details><details>  <summary>src和href的区别</summary>  TEST</details><details>  <summary>img的srcset的作用</summary>  TEST</details><details>  <summary>还有什么标签可以实现类似的功能？</summary>  TEST</details><details>  <summary>前端存储的方式</summary>  TEST</details><details>  <summary>这些方式的区别</summary>  TEST</details>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;details&gt;
  &lt;summary&gt;doctype（文档类型）的作用是什么？&lt;/summary&gt;
  TEST
&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;这三种模式的区别是什么？&lt;/summary&gt;
</summary>
      
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的前端面试题 - JS 篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20JS%20%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20JS%20%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.129Z</published>
    <updated>2025-07-18T06:03:17.129Z</updated>
    
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的前端面试题 - HTTP和浏览器篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTTP%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTTP%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.129Z</published>
    <updated>2025-07-18T06:03:17.129Z</updated>
    
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的前端面试题 - NodeJS 篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20NodeJS%20%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20NodeJS%20%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.129Z</published>
    <updated>2025-07-18T06:03:17.129Z</updated>
    
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>收集的前端面试题 - React 篇</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20React%20%E7%AF%87/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20React%20%E7%AF%87/</id>
    <published>2025-07-18T06:03:17.129Z</published>
    <updated>2025-07-18T06:03:17.129Z</updated>
    
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 中 Loader 和 Plugin 的区别</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E5%B7%A5%E7%A8%8B%E5%8C%96/Webpack%E4%B8%ADLoader%E5%92%8CPlugin%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E5%B7%A5%E7%A8%8B%E5%8C%96/Webpack%E4%B8%ADLoader%E5%92%8CPlugin%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-07-18T06:03:17.129Z</published>
    <updated>2025-07-18T06:03:17.129Z</updated>
    
    <content type="html"><![CDATA[<p>简单的说：</p><p>Loader是一个模块转换器，将非JS模块转换成JS模块；<br>Plugin是webpack运行生命周期的各个阶段上挂载的事件，会被指定的时间节点被触发（相当于订阅/发布模式），能够改变构建结果、拆分和优化bundle等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单的说：&lt;/p&gt;
&lt;p&gt;Loader是一个模块转换器，将非JS模块转换成JS模块；&lt;br&gt;Plugin是webpack运行生命周期的各个阶段上挂载的事件，会被指定的时间节点被触发（相当于订阅/发布模式），能够改变构建结果、拆分和优化bundle等。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Webpack" scheme="http://havebear.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>富文本里面， 是如何做到划词的</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E5%AF%8C%E6%96%87%E6%9C%AC%E9%87%8C%E9%9D%A2%EF%BC%8C%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%88%92%E8%AF%8D%E7%9A%84/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E5%AF%8C%E6%96%87%E6%9C%AC%E9%87%8C%E9%9D%A2%EF%BC%8C%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%88%92%E8%AF%8D%E7%9A%84/</id>
    <published>2025-07-18T06:03:17.128Z</published>
    <updated>2025-07-18T06:03:17.128Z</updated>
    
    <content type="html"><![CDATA[<p>在富文本环境中实现划词（鼠标滑动选择一组字符并对其进行操作）通常涉及以下几个关键步骤和技术：</p><ul><li>事件监听<ul><li>监听鼠标按下、鼠标移动和鼠标松开这三个主要的鼠标事件。当鼠标按下时，标记选择的开始；在鼠标移动过程中，根据鼠标的位置更新选择范围；鼠标松开时，确定最终的选择。</li></ul></li><li>选择范围计算<ul><li>使用浏览器提供的 Selection 对象来获取和管理选择的范围。在鼠标移动过程中，不断更新 Selection 对象的范围。</li></ul></li><li>操作处理<ul><li>一旦选择完成，可以根据具体的需求对选中的字符进行操作。例如，修改样式（如加粗、变色）、获取选中的文本内容、执行复制粘贴等操作。</li></ul></li></ul><p>示例（展示了如何获取选中的文本）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段示例文本，您可以尝试选中一部分。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseup&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> selection = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (selection) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> selectedText = selection.<span class="title function_">toString</span>();</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;选中的文本: &quot;</span>, selectedText);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在富文本环境中实现划词（鼠标滑动选择一组字符并对其进行操作）通常涉及以下几个关键步骤和技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件监听&lt;ul&gt;
&lt;li&gt;监听鼠标按下、鼠标移动和鼠标松开这三个主要的鼠标事件。当鼠标按下时，标记选择的开始；在鼠标移动过程中，根据鼠标的位置更新选择范围</summary>
      
    
    
    
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>AMD、CMD 和 CommonJS 的区别</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E5%B7%A5%E7%A8%8B%E5%8C%96/AMD%E3%80%81CMD%20%E5%92%8C%20CommonJS%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E5%B7%A5%E7%A8%8B%E5%8C%96/AMD%E3%80%81CMD%20%E5%92%8C%20CommonJS%20%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-07-18T06:03:17.128Z</published>
    <updated>2025-07-18T06:03:17.128Z</updated>
    
    <content type="html"><![CDATA[<p>CommonJS<br>　　CommonJS 是以在浏览器环境之外构建 javaScript 生态系统为目标而产生的写一套规范，主要是为了解决 javaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行，该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或者接口，通过 require() 来导入其他模块的输出到当前模块的作用域中；目前在服务器和桌面环境中，node.js 遵循的是 CommonJS 的规范；</p><p>　　CommonJS 对模块的加载时同步的；</p><p>AMD<br>　　AMD 主要是为前端 js 的表现指定的一套规范；而 CommonJS 是主要为了 js 在后端的表现制定的，它不适合前端；</p><p>　　AMD 是 Asynchronous Module Definition 的缩写，意思是 异步模块定义；采用的是异步的方式进行模块的加载，在加载模块的时候不影响后边语句的运行；</p><p>　　AMD 也是采用 require() 语句加载模块的，但是不同于 CommonJS ，它有两个参数；require([‘模块的名字’]，callBack)；requireJs 遵循的就是 AMD 规范；</p><p>CMD<br>　　CMD 是 Common Module Definition 的缩写，是 seajs 推荐的一套规范，CMD 也是通过异步的方式进行模块的加载的，不同于 AMD 的是，CMD 的加载是按照就近规则进行的，AMD 依赖的是前置；CMD 在加载的使用的时候会把模块变为字符串解析一遍才知道依赖了哪个模块；</p><p>　　CommonJS 其实也有浏览器端的实现，原理是先将所有模块都定义好并通过 id 索引方便的在浏览器环境中进行解析；</p><p>　　AMD 的实现其实是通过 define 函数定义在闭包中，例如：define(id?: String，dependencies?: String[]，factory: Function | Object)；</p><p>　　　　其中，id 是模块的名字，是一个可选的参数；dependencied 指定了所要依赖的模块列表，是一个数组，每个依赖的模块的输出将作为参数一次传入 factory 中；如果没有指定 dependencies 的话，那么默认的就是 [“require”，”exports”，”module”]；factory 包括了模块的具体实现，它是一个函数或者对象；如果是函数，那么它的返回值就是模块的输出接口或者值；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CommonJS&lt;br&gt;　　CommonJS 是以在浏览器环境之外构建 javaScript 生态系统为目标而产生的写一套规范，主要是为了解决 javaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行，该规范的主要内容是，模块必须通过 mod</summary>
      
    
    
    
    
    <category term="转载" scheme="http://havebear.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="面试" scheme="http://havebear.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端" scheme="http://havebear.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2025-07-18T06:03:17.122Z</published>
    <updated>2025-07-18T06:03:17.122Z</updated>
    
    
    
    
    
    <category term="设计模式" scheme="http://havebear.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
