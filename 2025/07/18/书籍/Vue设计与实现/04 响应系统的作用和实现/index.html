<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Vue.js 设计与实现 - 04 响应系统的作用和实现 | Have Bear</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="响应系统也是 Vue.js 的重要组成部分。在本章中，首先讨论什么是响应式数据和副作用函数，然后尝试实现一个相对完善的响应系统。在这个过程中，我们会遇到各种各样的问题，例如如何避免无限递归？为什么需要嵌套的副作用函数？两个副作用函数之间会产生哪些影响？以及其他需要考虑的细节。 第二篇 响应系统 响应式数据 副作用函数 Proxy WekaMap Set Map">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue.js 设计与实现 - 04 响应系统的作用和实现">
<meta property="og:url" content="http://havebear.com/2025/07/18/%E4%B9%A6%E7%B1%8D/Vue%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/04%20%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Have Bear">
<meta property="og:description" content="响应系统也是 Vue.js 的重要组成部分。在本章中，首先讨论什么是响应式数据和副作用函数，然后尝试实现一个相对完善的响应系统。在这个过程中，我们会遇到各种各样的问题，例如如何避免无限递归？为什么需要嵌套的副作用函数？两个副作用函数之间会产生哪些影响？以及其他需要考虑的细节。 第二篇 响应系统 响应式数据 副作用函数 Proxy WekaMap Set Map">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-18T06:03:17.103Z">
<meta property="article:modified_time" content="2025-07-18T06:03:17.103Z">
<meta property="article:author" content="havebear">
<meta property="article:tag" content="阅读">
<meta property="article:tag" content="Vue.js 设计与实现">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Have Bear" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Have Bear</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://havebear.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><!-- 文章列表 -->

<article id="post-书籍/Vue设计与实现/04 响应系统的作用和实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E4%B9%A6%E7%B1%8D/Vue%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/04%20%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2025-07-18T06:03:17.103Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Vue.js 设计与实现 - 04 响应系统的作用和实现
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>响应系统也是 Vue.js 的重要组成部分。在本章中，首先讨论什么是<code>响应式数据</code>和<code>副作用函数</code>，然后尝试实现一个相对完善的响应系统。在这个过程中，我们会遇到各种各样的问题，例如如何避免无限递归？为什么需要嵌套的副作用函数？两个副作用函数之间会产生哪些影响？以及其他需要考虑的细节。</p>
<p><code>第二篇 响应系统</code> <code>响应式数据</code> <code>副作用函数</code> <code>Proxy</code> <code>WekaMap</code> <code>Set</code> <code>Map</code></p>
<span id="more"></span>

<h3 id="4-1-响应式数据与副作用函数"><a href="#4-1-响应式数据与副作用函数" class="headerlink" title="4.1 响应式数据与副作用函数"></a>4.1 响应式数据与副作用函数</h3><p>副作用函数指的是会产生副作用的函数（影响其他函数执行）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;hello world&#x27;</span> <span class="comment">// 其他函数也有相同的行为，导致不符合预期</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effect2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  count = <span class="number">1</span> <span class="comment">// 修改全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应式数据，假设在一个副作用函数中读取了某个对象的属性，该属性发生变化时，该副作用函数重新执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">text</span>: <span class="string">&#x27;123&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">text</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-响应式数据的基本实现"><a href="#4-2-响应式数据的基本实现" class="headerlink" title="4.2 响应式数据的基本实现"></a>4.2 响应式数据的基本实现</h3><p>如何让 obj 变成响应式对象呢 —— 使用 Proxy 实现</p>
<ul>
<li>effect 执行，触发 obj.text 的读取操作，存储 effect</li>
<li>修改 obj.text，触发字段 obj.text 的设置操作，把存储的 effect 取出执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储副作用函数的桶</span></span><br><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据的代理</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 拦截读取操作</span></span><br><span class="line">  <span class="title function_">get</span> (target, key) &#123;</span><br><span class="line">    bucket.<span class="title function_">add</span>(effect)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">target</span>(target[key])</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截设置操作</span></span><br><span class="line">  <span class="title function_">set</span> (target, key, newVal) &#123;</span><br><span class="line">    target[key] = newVal</span><br><span class="line">    bucket.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 表示设置成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-设计一个完善的响应式系统"><a href="#4-3-设计一个完善的响应式系统" class="headerlink" title="4.3 设计一个完善的响应式系统"></a>4.3 设计一个完善的响应式系统</h3><p>明确<code>副作用函数</code>与被操作的的目标字段之间建立明确的关系。</p>
<p>角色：</p>
<ul>
<li>代理对象（target）</li>
<li>属性（key）</li>
<li>副作用函数 （effectFn）</li>
</ul>
<p>关系（WeakMap）：</p>
<table>
<thead>
<tr>
<th>target（Map）</th>
<th align="center">key（Set）</th>
<th align="right">effectfn</th>
</tr>
</thead>
<tbody><tr>
<td>target1</td>
<td align="center">key1</td>
<td align="right">effectFn1</td>
</tr>
<tr>
<td>target1</td>
<td align="center">key2</td>
<td align="right">effectFn1<br>effectFn2</td>
</tr>
<tr>
<td>target2</td>
<td align="center">key3</td>
<td align="right">effectFn2</td>
</tr>
</tbody></table>
<p>其他：</p>
<ul>
<li>effect，注册副作用函数，effect(() =&gt; { console.log(target1.key1) })</li>
<li>activeEffect，存储被注册的副作用函数，保存副作用函数的名字，也能处理匿名函数</li>
<li>bucket，存储所有副作用函数的桶</li>
</ul>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="comment">// 临时存储副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册副作用函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = fn =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect</span></span><br><span class="line">  activeEffect = fn</span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 get 拦截函数内调用 track 函数追踪变化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">track</span> = (<span class="params">target, key</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 没有副作用函数，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key --&gt; effects</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="comment">// 如果不存在 depsMap，那么新建一个 Map 并与 target 关联</span></span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    bucket.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据 key 从 depsMap 中取得 deps，它是一个 Set 类型</span></span><br><span class="line">  <span class="comment">// 里面存储着所有与当前 key 相关联的副作用函数：effects</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="comment">// 如果不存在 deps，同样新建一个 Set 并与 key 关联</span></span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后将当前激活的副作用函数添加到“桶”里</span></span><br><span class="line">  deps.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 set 拦截函数内调用 trigger 函数触发变化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">trigger</span> = (<span class="params">target, key</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 根据 target 从桶中取得 depsMap，它是 key --&gt; effects</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据 key 取得所有副作用函数 effects</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="title function_">get</span> (target, key) &#123;</span><br><span class="line">    <span class="comment">// 将副作用函数 activeEffect 添加到存储副作用函数的桶中</span></span><br><span class="line">    <span class="title function_">track</span>(target, key)</span><br><span class="line">    <span class="comment">// 返回属性值</span></span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span> (target, key, newVal) &#123;</span><br><span class="line">    <span class="comment">// 设置属性值</span></span><br><span class="line">    target[key] = newVal</span><br><span class="line">    <span class="title function_">trigger</span>(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册副作用函数</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">text</span>)</span><br><span class="line">&#125;)  <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">text</span> = <span class="string">&#x27;123&#x27;</span>  <span class="comment">// 123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tips:</p>
<ul>
<li>key 对应的 Set 数据结构中存储的副作用函数集合称为<code>依赖集合</code></li>
<li>WeakMap 对 key 是弱引用，一旦没有其他引用与该对象关联，则垃圾回收机制会回收该对象所占用的内存</li>
</ul>
<h3 id="4-4-分支切换与-cleanup"><a href="#4-4-分支切换与-cleanup" class="headerlink" title="4.4 分支切换与 cleanup"></a>4.4 分支切换与 cleanup</h3><p>分支切换的定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">ok</span>: <span class="literal">true</span>, <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = obj.<span class="property">ok</span>? obj.<span class="property">text</span> : <span class="string">&#x27;not&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>函数内部存在一个三元表达式，obj.ok 的值发生变化时，代码执行的分支也会跟着变化，这就是所谓的分支切换。</p>
<p>分支的切换可能会产生遗留的副作用函数，如下面的代码，除了没有删除之前存储的副作用函数，遗留的副作用函数还会导致不必要的更新，obj.text 更新后仍然会触发副作用函数执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">ok</span>: <span class="literal">true</span>, <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">ok</span> ? obj.<span class="property">text</span> : <span class="string">&#x27;noOk&#x27;</span>)</span><br><span class="line">&#125;) <span class="comment">// hello world</span></span><br><span class="line"><span class="comment">// bucket 存储了 ok 和 text 对应的副作用函数</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">ok</span> = <span class="literal">false</span> <span class="comment">// noOk</span></span><br><span class="line"><span class="comment">// bucket 仍然存储了 ok 和 text 对应的副作用函数，没有删除 text 对应的副作用函数</span></span><br></pre></td></tr></table></figure>

<p>解决这个问题的思路：每次副作用函数执行时，可以把它从所有与之关联的依赖集合中删除。</p>
<p>副作用函数执行完毕后，会重新建立联系，但在新的联系中不会包含遗留的副作用函数。</p>
<p>要将一个副作用函数从所有与之关联的依赖集合中移除，需要明确知道哪些依赖集合中包含它，因此在 effect 内部定义了新的 effectFn 函数，并为其添加 effectFn.deps 属性（数组），用来存储所有包含当前副作用函数的依赖集合：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在副作用函数执行前，将副作用函数从依赖集合中移除</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cleanup</span> = effectFn =&gt; &#123;</span><br><span class="line">  <span class="comment">// 遍历 effectFn.deps 数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; effectFn.<span class="property">deps</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// deps 是依赖集合</span></span><br><span class="line">    <span class="keyword">const</span> deps = effectFn.<span class="property">deps</span>[i]</span><br><span class="line">    <span class="comment">// 将 effectFn 从依赖集合中删除</span></span><br><span class="line">    <span class="comment">// Set.prototype.delete(value) 删除某个值</span></span><br><span class="line">    deps.<span class="title function_">delete</span>(effectFn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后需要重置 effectFn.deps 数组</span></span><br><span class="line">  effectFn.<span class="property">deps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = fn =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在调用 cleanup 函数完成清除工作</span></span><br><span class="line">    <span class="title function_">cleanup</span>(effectFn)</span><br><span class="line">    <span class="comment">// 当 effectFn 执行时，将其设置为当前激活的副作用函数</span></span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储所有与该副作用函数相关联的依赖集合</span></span><br><span class="line">  <span class="comment">// activeEffect.deps</span></span><br><span class="line">  effectFn.<span class="property">deps</span> = []</span><br><span class="line">  <span class="title function_">effectFn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">track</span> = (<span class="params">target, key</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    bucket.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 副作用函数集合</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把当前激活的副作用函数添加到依赖集合中</span></span><br><span class="line">  deps.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">  <span class="comment">// 将其添加到 activeEffect.deps 数组中</span></span><br><span class="line">  activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(deps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cleanup 函数接收副作用函数作为参数，遍历副作用函数的 effectFn.deps 数组，将该副作用函数从数组的每一项（依赖集合，即副作用函数集合）中移除，最后重置 effectFn.deps 数组。至此，可以<code>避免副作用函数遗留</code>。</p>
<p>解决<code>无限循环执行</code>的问题，问题出现在 trigger 函数内部的 <code>effects &amp;&amp; effects.forEach(fn =&gt; fn())</code>中，当副作用函数执行时，会调用 cleanup 进行清除，实际上是从 effects 集合中将当前执行的副作用函数剔除。但是副作用函数的执行会导致其重新被收集到集合中，而此时对于 effects 集合的遍历仍在进行。</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  set.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br><span class="line">  set.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;遍历中&#x27;</span>)</span><br><span class="line">&#125;) <span class="comment">// 无限循环执行</span></span><br></pre></td></tr></table></figure>
<p>规范：</p>
<p>在调用 forEach 遍历 Set 集合，如果一个值已经被访问过，但是该值被删除重新添加到集合，如果此时遍历未结束，那么该值会被重新访问。因此，上面的代码会无限执行，解决办法就是构造另一个 Set 集合并遍历它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newSet = <span class="keyword">new</span> <span class="title class_">Set</span>(set)</span><br><span class="line">newSet.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  set.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br><span class="line">  set.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;遍历中&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">trigger</span> = (<span class="params">target, key</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">const</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>(effects) <span class="comment">// +</span></span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> <span class="title function_">effectFn</span>()) <span class="comment">// +</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-嵌套的-effect-与-effect-栈"><a href="#4-5-嵌套的-effect-与-effect-栈" class="headerlink" title="4.5 嵌套的 effect 与 effect 栈"></a>4.5 嵌套的 effect 与 effect 栈</h3><p>effect 是可以发生嵌套的（相当于 Vue 中的组件嵌套，A 组件渲染了 B 组件。），如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/**  */</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;effectFn1 执行&#x27;</span>)</span><br><span class="line">  <span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;effectFn2 执行&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">text</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">text</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="comment">// effectFn1 执行 -&gt; 不符合预期</span></span><br><span class="line"><span class="comment">// effectFn2 执行</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>我们用全局变量 activeEffect 来存储通过 effect 函数注册的副作用函数，这意味着同一时刻 activeEffect 所存储的副作用函数只能有一个。当副作用函数发生嵌套时，内层的副作用函数会覆盖 activeEffect 的值，并且永远不会恢复到原来的值。这时如果再有响应式数据进行依赖收集，即使这个响应式数据是在外层副作用函数中读取的，它们收集到的副作用函数也都是内存副作用函数，这就是问题的所在。</p>
<p>为了解决这个问题，需要一个副作用函数栈 effectStack，在副作用函数执行时，将当前副作用函数压入栈中，并始终让 activeEffect 指向栈顶的副作用函数。这样就能做到一个响应式数据只会收集直接读取其值的副作用函数，而不会出现互相影响的情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"><span class="keyword">const</span> effectStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = fn =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">cleanup</span>(effectFn)</span><br><span class="line">    <span class="comment">// 调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect</span></span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    <span class="comment">// 调用副作用函数之前，将副作用函数压入栈中</span></span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn)</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">    <span class="comment">// 当前副作用函数执行完毕后，将其从栈中弹出，并把 activeEffect 还原为之前的值</span></span><br><span class="line">    effectStack.<span class="title function_">pop</span>()</span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  effectFn.<span class="property">deps</span> = []</span><br><span class="line">  <span class="title function_">effectFn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-避免无限递归循环"><a href="#4-6-避免无限递归循环" class="headerlink" title="4.6 避免无限递归循环"></a>4.6 避免无限递归循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123; <span class="comment">/** */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  obj.<span class="property">foo</span>++</span><br><span class="line">&#125;) <span class="comment">// 栈溢出</span></span><br></pre></td></tr></table></figure>

<p>在 <code>obj.foo++</code> 中，即会读取 <code>obj.foo</code> 的值，又会设置 <code>obj.foo</code>的值，而这就是导致问题的根本原因，流程：</p>
<ul>
<li>首先读取 <code>obj.foo</code> 的值，触发 <code>track</code> 操作，将当前副作用函数收集到 <code>obj.foo</code> 的依赖集合中（deps）</li>
<li>接着将其值加 1，触发 set 操作，触发 <code>trigger</code> 操作，将副作用函数从 <code>obj.foo</code> 的依赖集合中（deps）取出并执行。</li>
</ul>
<p>问题在于副作用函数正在执行中，还没执行完毕，就要开始下一次执行。这样会导致无限递归地调用自己，于是产生了栈溢出。</p>
<p>解决办法并不难。通过分析可得，读取和设置操作是在同一个副作用函数内进行的，此时无论是 <code>track</code> 时收集的副作用函数，还是<code>trigger</code>时要触发执行的副作用函数，都是 <code>activeEffect</code>。基于此，我们可以在 trigger 动作发生时增加守卫：如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123; <span class="comment">/** */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">trigger</span> = (<span class="params">target, key</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">const</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>( =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</span></span><br><span class="line">    <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">      effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> <span class="title function_">effectFn</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-调度执行"><a href="#4-7-调度执行" class="headerlink" title="4.7 调度执行"></a>4.7 调度执行</h3><p><strong>可调度性是响应式系统非常重要的特性</strong>，什么是可调度行？</p>
<ul>
<li>指的是当 trigger 动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式。</li>
</ul>
<p>如何决定副作用函数的执行方式？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;  <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123; <span class="comment">/** */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 结束</span></span><br></pre></td></tr></table></figure>

<p>调整输出的顺序，如 1，结束，2，除了把代码语句互换，有什么能够在不调整代码的情况下实现呢 —— 这时候就需要响应式系统支持调度。</p>
<p>为 effect 函数设计一个选项参数 <code>options</code>，允许用户指定调度器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// options</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 调度器</span></span><br><span class="line">    <span class="attr">scheduler</span>: <span class="function"><span class="params">fn</span> =&gt;</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>options 对象可以指定一个 scheduler 调度函数，同时在 effect 函数内部我们需要把 options 挂载到对应的副作用函数上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = (<span class="params">fn, options = &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">cleanup</span>(effectFn)</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn)</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">    effectStack.<span class="title function_">pop</span>()</span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  effectFn.<span class="property">options</span> = options  <span class="comment">// 将 options 挂载到 effectFn 上</span></span><br><span class="line">  effectFn.<span class="property">deps</span> = []</span><br><span class="line">  <span class="title function_">effectFn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了调度函数，我们在 trigger 函数中触发执行副作用函数时，就可以直接调用用户传递的调度器函数，从而把控制权浇给用户：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">trigger</span> = (<span class="params">target, key</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">const</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item !== activeEffect) &#123;</span><br><span class="line">      effectsToRun.<span class="title function_">add</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果存在调度器，则调用该调度器，并将副作用函数作为参数传递</span></span><br><span class="line">    <span class="keyword">if</span> (effectFn.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;</span><br><span class="line">      effectFn.<span class="property">options</span>.<span class="title function_">scheduler</span>(effectFn)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则执行副作用函数</span></span><br><span class="line">      <span class="title function_">effectFn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，在 trigger 函数中，我们判断如果存在调度器，则调用该调度器，并将副作用函数作为参数传递，否则执行副作用函数，由用户自己控制如何执行；否则保留之前的行为，即执行副作用函数。</p>
<p>回到开头的需求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;  <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123; <span class="comment">/** */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 调度器</span></span><br><span class="line">    <span class="attr">scheduler</span>: <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将副作用函数放倒到“宏任务”队列中执行</span></span><br><span class="line">      <span class="comment">// 在这里我们开启一个宏任务来执行副作用函数 fn，实现期望的打印顺序</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>除了控制副作用函数的<strong>执行顺序</strong>，通过调度器还可以控制它的<strong>执行次数</strong>，这点也尤为重要，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span>++</span><br><span class="line">obj.<span class="property">foo</span>++</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>由输出可知，字段 obj.foo 的值一定会从 1 自增到 3，2 只是它的过度状态，如果我们只关心结果，不关心过程，那么执行三次打印操作就是多余的，期望的打印结果是 1，3，基于调度器实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务队列，Set 的自动去重能力</span></span><br><span class="line"><span class="keyword">const</span> jobQueue = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="comment">// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列中</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否正在刷新队列</span></span><br><span class="line"><span class="keyword">let</span> isFlushing = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">flushJob</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果队列正在刷新，则什么都不做</span></span><br><span class="line">  <span class="keyword">if</span> (isFlushing) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置为 true，代表正在刷新</span></span><br><span class="line">  isFlushing = <span class="literal">true</span></span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清空队列</span></span><br><span class="line">    jobQueue.<span class="title function_">forEach</span>(<span class="function"><span class="params">job</span> =&gt;</span> <span class="title function_">job</span>())</span><br><span class="line">  &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 重置 isFlushing</span></span><br><span class="line">    isFlushing = <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 调度器</span></span><br><span class="line">    <span class="attr">scheduler</span>: <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 每次调度时，将副作用函数添加到 jobQueue 队列中</span></span><br><span class="line">      jobQueue.<span class="title function_">add</span>(fn)</span><br><span class="line">      <span class="comment">// 调用 flushJob 刷新队列</span></span><br><span class="line">      <span class="title function_">flushJob</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span>++</span><br><span class="line">obj.<span class="property">foo</span>++</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>每次 scheduler 调度函数执行时，将副作用函数添加到 jobQueue 队列中，然后调用 flushJob 刷新队列。</p>
<p>关于 flushJob，该函数通过 isFlushing 判断是否执行，只有为 false 时才会执行，并将 isFlushing 设为 true，无论调用多少次 flushJob 函数，在 jobQueue 的副作用函数执行完之前只会执行一次。 </p>
<p>在这里借助了 js 执行机制，同步代码 -&gt; 微任务 -&gt; 下一个宏任务。该功能类似 Vue 中连续多次修改响应式数据但只会触发一次更新，实际上 Vue 内部实现了更完善的调度器。</p>
<h3 id="4-8-计算属性-computed-与-lazy"><a href="#4-8-计算属性-computed-与-lazy" class="headerlink" title="4.8 计算属性 computed 与 lazy"></a>4.8 计算属性 computed 与 lazy</h3><p>在深入讲解计算属性之前，需要先聊聊懒执行的 effect，即 lazy 的 effect。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(</span><br><span class="line">  <span class="comment">// 这个函数会立即执行</span></span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>有些场景下，我们并不希望它立即执行，而是希望它在需要的时候执行，如计算属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(</span><br><span class="line">  <span class="comment">// 这个函数会立即执行</span></span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params">fn, options = &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">cleanup</span>(effectFn)</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn)</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">    effectStack.<span class="title function_">pop</span>()</span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  effectFn.<span class="property">options</span> = options</span><br><span class="line">  effectFn.<span class="property">deps</span> = []</span><br><span class="line">  <span class="comment">// 只有非懒执行的时候才执行</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="title function_">effectFn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将副作用函数作为返回值返回</span></span><br><span class="line">  <span class="keyword">return</span> effectFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 options.lazy 实现了让副作用函数不立即执行的功能，那么副作用函数该什么时候执行呢？这里将副作用函数作为返回值返回，只要调用 effect，就能拿到对应的副作用函数，在需要的时候执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>)</span><br><span class="line">&#125;, &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">// 手动执行副作用函数</span></span><br><span class="line"><span class="title function_">effectFn</span>()</span><br></pre></td></tr></table></figure>

<p>❗如果我们把传递给 effect 的函数当作一个 getter，返回一个返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="property">foo</span> + obj.<span class="property">bar</span></span><br><span class="line">&#125;, &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">// value 是 传入 effect 函数的返回值</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="title function_">effectFn</span>()</span><br></pre></td></tr></table></figure>

<p>为了实现这个目标，需要对 effect 函数做一些修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = (<span class="params">fn, options = &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">cleanup</span>(effectFn)</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn)</span><br><span class="line">    <span class="comment">// 将 fn 的执行结果存储到 res 中</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">fn</span>()</span><br><span class="line">    effectStack.<span class="title function_">pop</span>()</span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 将 res 作为 effectFn 的返回值</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  effectFn.<span class="property">options</span> = options</span><br><span class="line">  effectFn.<span class="property">deps</span> = []</span><br><span class="line">  <span class="comment">// 只有非懒执行的时候才执行</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="title function_">effectFn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将副作用函数作为返回值返回</span></span><br><span class="line">  <span class="keyword">return</span> effectFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码可知，传递给 effect 函数的参数 fn 才是真正的副作用函数，而 effectFn 是我们包装后的副作用函数。为了通过 effectFn 得到真正的副作用函数 fn 的执行结果，我们需要将其保存到 res 变量中，然后将其作为 effectFn 函数的返回值。</p>
<p>现在我们已经能够实现懒执行的副作用函数，并且能够拿到副作用函数的执行结果，接下来可以实现计算属性了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">computed</span> = getter =&gt; &#123;</span><br><span class="line">  <span class="comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="comment">// 当读取 value 时，手动调用副作用函数，获取到的值就是返回值</span></span><br><span class="line">    get <span class="title function_">value</span> () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">effectFn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123; <span class="comment">/** */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> obj.<span class="property">foo</span> + obj.<span class="property">bar</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum.<span class="property">value</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>可以看到它能正确工作，不过现在的计算属性只做到了懒计算（只有真正读取 sum.value 的值时，才会进行计算并得到值），还做不到对值进行缓存，假如我们多次访问 sum.value，会导致 effectFn 进行多次计算（每次访问，都会调用 effectFn 重新计算），即使 obj.bar 和 obj.bar 的值并没有发生变化。</p>
<p>为了解决这个问题，需要在 computed 函数中添加缓存功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">computed</span> = getter =&gt; &#123;</span><br><span class="line">  <span class="comment">// 定义一个变量存储上一次计算的值</span></span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="comment">// dirty 标志，代表是否需要重新计算值，为 true 则意味着需要重新计算</span></span><br><span class="line">  <span class="keyword">let</span> dirty = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 添加调度器，在调度器中将 dirty 重置为 true</span></span><br><span class="line">    <span class="comment">// 当数据变化时，将 dirty 置为 true，表示下一次读取需要重新计算</span></span><br><span class="line">    <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      dirty = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="comment">// 当读取 value 时，手动调用副作用函数，获取到的值就是返回值</span></span><br><span class="line">    get <span class="title function_">value</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = <span class="title function_">effectFn</span>()</span><br><span class="line">        <span class="comment">// 将 dirty 设置为 false，下一次访问直接使用缓存到 value 中的值</span></span><br><span class="line">        dirty = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们设计的计算属性已经趋于完美，但还有一个缺陷（不会触发读取该计算属性的副作用函数的执行），它体现在当我们在另一个 effect 中读取计算属性的值时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> obj.<span class="property">foo</span> + obj.<span class="property">bar</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sum.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span>++ <span class="comment">// 并不会触发副作用函数的执行</span></span><br></pre></td></tr></table></figure>

<p>分析问题的原因，我们发现，这本质上是一个 effect 的嵌套。一个计算属性内部拥有自己的 effect，并且它是懒执行的，只有当真正读取计算属性的值时才会执行。对于计算属性的 getter 函数来说，它里面访问的响应式数据只会把 computed 内部的 effect 收集为依赖。而把计算属性用作与另一个 effect 时，就会发生 effect 嵌套，外层的 effect 不会被内层 effect 中的响应式数据收集。</p>
<p>解决办法很简单，当读取计算属性的值时，我们可以手动调用 track 函数进行追踪，当计算属性依赖的响应式数据发生变化时，我们可以手动调用 trigger 函数触发响应：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">computed</span> = getter =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">let</span> dirty = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      dirty = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 当计算属性依赖的响应式数据变化时，手动调用 trigger 函数触发响应</span></span><br><span class="line">      <span class="title function_">trigger</span>(obj, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    get <span class="title function_">value</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = <span class="title function_">effectFn</span>()</span><br><span class="line">        dirty = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当读取 value 时，手动调用 track 函数进行追踪</span></span><br><span class="line">      <span class="title function_">track</span>(obj, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，计算属性的实现已经基本完成。对于如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">effectFn</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sum.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>它会建立这样的关系：</p>
<p>computed(obj)<br>&nbsp;&nbsp;&nbsp;&nbsp;- value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- effectFn</p>
<h3 id="4-9-watch-的实现原理"><a href="#4-9-watch-的实现原理" class="headerlink" title="4.9 watch 的实现原理"></a>4.9 watch 的实现原理</h3><p>所谓 watch，其本质就是观测一个响应式数据，当数据发生变化时通知并执行相应的回调函数，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(obj, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据变了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改响应数据的值，触发回调函数</span></span><br><span class="line">obj.<span class="property">foo</span>++</span><br></pre></td></tr></table></figure>

<p>实际上，watch 实现的本质是利用了 effect 以及 options.scheduler 选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>)</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当 obj.foo 发生变化时，会执行 scheduler 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当响应式数据发生变化时，会触发 scheduler 执行，基于此，简单的 watch 实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">watch</span> = (<span class="params">source, cb</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">effect</span>(</span><br><span class="line">    <span class="comment">// 触发读取操作，从而建立联系</span></span><br><span class="line">    <span class="function">() =&gt;</span> source.<span class="property">foo</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当数据变化时，执行回调函数</span></span><br><span class="line">        <span class="title function_">cb</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(obj, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据变了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里硬编码了 obj.foo，为了让 watch 函数具有通用性，需要封装一个通用的读取操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">watch</span> = (<span class="params">source, cb</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">effect</span>(</span><br><span class="line">    <span class="comment">// 调用 traverse 递归读取</span></span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当数据变化时，执行回调函数</span></span><br><span class="line">        <span class="title function_">cb</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">traverse</span> = (<span class="params">value, seen = <span class="keyword">new</span> <span class="built_in">Set</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果读取的数据是原始值，或者已经被读取过了，那么什么都不做</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value!== <span class="string">&#x27;object&#x27;</span> || value === <span class="literal">null</span> || seen.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将数据添加到 seen 中，表示已读取（避免循环引用导致的死循环）</span></span><br><span class="line">  seen.<span class="title function_">add</span>(value)</span><br><span class="line">  <span class="comment">// 暂时不考虑数组等其他结构</span></span><br><span class="line">  <span class="comment">// 假设 value 是一个对象，使用 for...in 读取对象的每一个值，并递归处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">    <span class="title function_">traverse</span>(value[key], seen)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对象任意属性发生变化时，都能触发回调函数执行。</p>
<p>watch 函数除了可以观测响应式数据，还可以接收一个 getter 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="comment">// getter 函数</span></span><br><span class="line">  <span class="function">() =&gt;</span> obj.<span class="property">foo</span>,</span><br><span class="line">  <span class="comment">// 回调函数</span></span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj.foo 变了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>传递给 watch 函数的第一个参数不再是一个响应式数据，二是一个 getter 函数，在 getter 函数内部，用户可以指定该 watch 依赖哪些响应式数据，只有当这些数据发生变化时，才会触发回调函数执行，下面的代码实现了这一功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">watch</span> = (<span class="params">source, cb</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 定义一个 getter 函数</span></span><br><span class="line">  <span class="keyword">let</span> getter</span><br><span class="line">  <span class="comment">// 如果 source 是函数，说明用户传递的是 getter，将其赋值给 getter</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    getter = source</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则按照原来的逻辑进行处理</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">effect</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">getter</span>(source),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当数据变化时，执行回调函数</span></span><br><span class="line">        <span class="title function_">cb</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常在 Vue 的 watch 函数中能拿到变化前后的值，那么如何获得新旧值呢？这需要充分利用 effect 函数的 lazy 选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">watch</span> = (<span class="params">source, cb</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> getter</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    getter = source</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldValue, newValue</span><br><span class="line">  <span class="comment">// 使用 effect 注册副作用函数时</span></span><br><span class="line">  <span class="comment">// 开启 lazy 选项，并把返回值保存到 effectFn 中以便后续手动调用</span></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">getter</span>(),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">scheduler</span>: &#123;</span><br><span class="line">        <span class="comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span></span><br><span class="line">        newValue = <span class="title function_">effectFn</span>()</span><br><span class="line">        <span class="comment">// 将旧值和新值作为回调函数的参数</span></span><br><span class="line">        <span class="title function_">cb</span>(newValue, oldValue)</span><br><span class="line">        <span class="comment">// 更新旧值，不然下一次会得到错误的旧值</span></span><br><span class="line">        oldValue = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 执行副作用函数，拿到的值就是旧值</span></span><br><span class="line">  oldValue = <span class="title function_">effectFn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-10-立即执行的-watch-与回调执行时机"><a href="#4-10-立即执行的-watch-与回调执行时机" class="headerlink" title="4.10 立即执行的 watch 与回调执行时机"></a>4.10 立即执行的 watch 与回调执行时机</h3><p>上一节介绍了 watch 的基本实现，在这个过程中，我们认识到 watch 的本质是对 effect 的二次封装，本节我们继续讨论：</p>
<ul>
<li>立即执行的函数回调</li>
<li>回调函数的执行时机</li>
</ul>
<p>立即执行的函数回调</p>
<p>默认情况下，一个 watch 的回调只会在响应式数据发生变化时才执行，但是在 Vue 中可以通过选项 immediate 来指定是否需要立即执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(obj, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据变了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当 immediate 为 true 时，回调函数辉在该 watch 创建时立刻执行一次。仔细思考发现，回调函数的立即执行与后续执行，没有本质的区别，所以我们可以把 scheduler 函数封装为一个通用函数，分别在初始化和变更时执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">watch</span> = (<span class="params">source, cb, options = &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> getter</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    getter = source</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> oldValue, newValue</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提取 scheduler 为一个独立的 job 函数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    newValue = <span class="title function_">effectFn</span>()</span><br><span class="line">    <span class="title function_">cb</span>(newValue, oldValue)</span><br><span class="line">    oldValue = newValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">getter</span>(),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">scheduler</span>: job</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">immediate</span>) &#123;</span><br><span class="line">    <span class="comment">// 当 imediate 为 true 时，执行 job，从而触发回调执行</span></span><br><span class="line">    <span class="title function_">job</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则执行副作用函数，拿到的值就是旧值</span></span><br><span class="line">    oldValue = <span class="title function_">effectFn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了指定回调函数为立即执行之外，还可以通过其他选项参数来指定函数的执行时机，例如 Vue3 中使用 flush 选项来指定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(obj, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据变了&#x27;</span>)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="comment">// 回调函数会在 watch 创建时立即执行一次</span></span><br><span class="line">  <span class="comment">// 还可以指定为 &#x27;post&#x27; | &#x27;sync&#x27;</span></span><br><span class="line">  <span class="attr">flush</span>: <span class="string">&#x27;pre&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>flush 本质上是在指定调度函数的执行时机，前文讲解过如何在微任务队列中执行调度函数 scheduler，这与 flush 的功能相同。当 flush 的值为 ‘post’ 时，代表调度函数需要将副作用函数放到一个微任务队列中，并等待 DOM 更新结束后再执行，我们可以用如下代码进行模拟：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">watch</span> = (<span class="params">source, cb, options</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> getter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-11-过期的副作用"><a href="#4-11-过期的副作用" class="headerlink" title="4.11 过期的副作用"></a>4.11 过期的副作用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finalData</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(obj, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">  finalData = res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>obj 每次发生变化时候，都会触发副作用函数的执行，如果第一次的结果覆盖了最后一次的结果，就会导致数据数据无效（状态同步问题）。这就需要一个让副作用过期的手段。</p>
<p>在 Vue 中，在 watch 内部每次监测到更新变更后，在副作用函数重新执行之前，会先调用通过 onInvalidate 函数注册过的过期回调函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">watch</span> = (<span class="params">source, cb, options = &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> getter</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    getter = source</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldValue, newValue</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cleanup 用来存储用户注册的过期回调</span></span><br><span class="line">  <span class="keyword">let</span> cleanup</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onInvalidate</span> = fn =&gt; &#123;</span><br><span class="line">    cleanup = fn</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    newVal = <span class="title function_">effectFn</span>()</span><br><span class="line">    <span class="comment">// 在调用回调函数 cb 之前，先调用过期回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">      <span class="title function_">cleanup</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">cb</span>(newVal, oldVal, onInvalidate)</span><br><span class="line">    oldValue = newValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(</span><br><span class="line">    <span class="comment">// 执行 getter 函数，触发读取</span></span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">getter</span>(),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">flush</span> === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">          p.<span class="title function_">then</span>(job)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">job</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">immediate</span>) &#123;</span><br><span class="line">    <span class="title function_">job</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    oldValue = <span class="title function_">effectFn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们首先定义了 cleanup 变量，这个变量用来存储用户通过 onInvalidate 函数注册的过期回调函数。在 job 函数内，每次执行回调函数 cb 之前，先检查是否存在过期回调，如果存在，则执行过期回调函数 cleanup。最后我们把 onInvalidate 函数作为参数传递给 cb，以便用户使用。</p>
<h3 id="4-12-总结"><a href="#4-12-总结" class="headerlink" title="4.12 总结"></a>4.12 总结</h3><p>在本章中，首先介绍了副作用函数和响应式数据的概念，以及它们的关系。一个响应式数据最基本的实现依赖于对“读取”和“设置”操作的拦截，从而在副作用函数与响应式数据之间建立联系。当“读取”操作发生时，我们将当前执行的副作用函数存储到“桶中”；当“设置”操作发生时，再将副作用函数从“桶”中取出并执行。这就是相应系统的根本实现原理。</p>
<p>接着我们实现了一个相对完善的响应式系统。使用 WeakMap 配合 Map 构建了新的“桶”结构，从而能够在响应式数据与副作用函数之间建立更加精确的联系。同时，我们也介绍了 WeakMap 和 Map 这两个数据结构之间的区别。WeakMap 是弱引用的，它不会影响垃圾回收器的工作。当用户代码对一个对象没有引用关系时，WeakMap 不会组织垃圾回收器回收该对象。</p>
<p>我们还讨论了分支切换导致的冗余副作用的问题，这个问题会导致副作用函数进行不必要的更新。为了解决这个问题，我们需要在每次副作用函数重新执行之前，清除上一次建立的响应联系，而当副作用函数重新执行后，会再次建立新的响应联系，新的响应联系中不存在冗余副作用的问题。但在此过程中，我们还遇到了遍历 Set 数导致无限循环的新问题（forEach 遍历 Set 集合，如果一个值被访问过了，但这个值被删除并重新添加到集合，如果 forEach 遍历没结束，那么这个值会被重新访问），解决方案是建立一个新的 Set 数据结构进行遍历。</p>
<p>然后我们讨论了关于嵌套的副作用函数的问题（父子组件），为了避免响应数据和副作用函数之间建立的关系错乱，我们需要使用栈来存储不同的副作用函数。当一个副作用函数执行完毕后，将其从栈顶弹出。当读取响应式数据的时候，被读取的响应式数据只会与当前栈顶的副作用函数建立响应关系。而后，我们还遇到了副作用函数无限递归调用自身，导致栈溢出的问题，该问题的原因在于对响应式数据的读取和设置操作发生在同一个副作用函数内。解决办法为：如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行。</p>
<p>随后，我们讨论了响应系统的可调度行（指 trigger 触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式）。为了实现调度能力，我们为 effecct 函数增加了第二个选项参数，可以通过 scheduler 指定调用器，这样用户可以通过调度器自行完成任务的调度。我们还讲解了如何通过调度器实现任务去重，即通过一个微任务队列对任务进行缓存，从而实现去重。</p>
<p>而后，我们讲解了计算属性，它实际上是一个懒执行的副作用函数，我们通过 lazy 使得副作用函数可以懒执行。被标记为懒执行的副作用函数可以通过手动方式让其执行。</p>
<p>之后，我们讨论了 watch 的实现原理，它本质上是利用了副作用函数重新执行时的可调度行，一个 watch 本身会创建一个 effect，当这个 effect 依赖的响应式数据发生变化时，会执行该 effect 的调度器函数，即 scheduler。这里的 scheduler 可以理解为“回调”，所以我们只需要在 scheduler 中执行用户通过 watch 注册的回调函数即可。此外还讲解了立即执行回调的 watch，通过添加新的 immediate 实现，还讨论了如何控制回调函数的执行时机，通过 flush 选项指定，本质上是利用了调用器和异步的微任务队列。</p>
<p>最后，我们讨论了过期的副作用函数，会导致状态同步的问题，为了解决这个问题，为 watch 设计了第三个参数 —— onInvalidate。它是一个函数，用来注册过期回调。每当 watch 的回调函数执行之前，会优先执行用户通过 onInvalidate 注册的过期回调函数。这样，用户就有机会在过期回调中将上一次的副作用标记为“过期”，从而解决“竞态”的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">ok</span>: <span class="literal">true</span>, <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// 存储副作用函数的桶</span></span><br><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="comment">// 用一个栈存储当前激活的副作用函数</span></span><br><span class="line"><span class="keyword">const</span> effectStack = []</span><br><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line"><span class="comment">// const jobQueue = new Set()</span></span><br><span class="line"><span class="comment">// 存储被注册的副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从所有的依赖集合中删除当前的副作用函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cleanup</span> = effectFn =&gt; &#123;</span><br><span class="line">  <span class="comment">// 遍历 effectFn.deps 数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; effectFn.<span class="property">deps</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// deps 是依赖集合</span></span><br><span class="line">    <span class="keyword">const</span> deps = effectFn.<span class="property">deps</span>[i]</span><br><span class="line">    <span class="comment">// 将 effectFn 从依赖集合中删除</span></span><br><span class="line">    deps.<span class="title function_">delete</span>(effectFn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后需要重置 effectFn.deps 数组</span></span><br><span class="line">  effectFn.<span class="property">deps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册副作用函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = (<span class="params">fn, options = &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 调用 cleanup 函数完成清除工作</span></span><br><span class="line">    <span class="title function_">cleanup</span>(effectFn)</span><br><span class="line">    <span class="comment">// 当 effectFn 执行时，将其设置为当前激活的副作用函数</span></span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    <span class="comment">// 调用副作用函数之前将当前副作用函数压入栈中</span></span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn)</span><br><span class="line">    <span class="comment">// 执行副作用函数，并保存返回值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">fn</span>()</span><br><span class="line">    <span class="comment">// 当前副作用函数执行完毕后，将其从栈中弹出，并把 activeEffect 还原为之前的值</span></span><br><span class="line">    effectStack.<span class="title function_">pop</span>()</span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 返回副作用函数的返回值</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 options 挂载到 effectFn 上</span></span><br><span class="line">  effectFn.<span class="property">options</span> = options</span><br><span class="line">  <span class="comment">// activeEffect.deps（effectFn.deps） 用来存储所有与该副作用函数相关的依赖集合</span></span><br><span class="line">  effectFn.<span class="property">deps</span> = []</span><br><span class="line">  <span class="comment">// 非 lazy 懒执行时，立即执行副作用函数</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行副作用函数</span></span><br><span class="line">    <span class="title function_">effectFn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将副作用函数作为返回值返回</span></span><br><span class="line">  <span class="keyword">return</span> effectFn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 get 拦截函数内调用 track 函数追踪变化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">track</span> = (<span class="params">target, key</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 没有 activeEffect，直接 return</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 根据 target 从“桶”中取得 depsMap，也是一个 Map 类型：key --&gt; effects</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="comment">// 如果不存在 depsMap，那么新建一个 Map 并与 target 关联</span></span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    bucket.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据 key 从 depsMap 中取得 deps，也是一个 Set 类型</span></span><br><span class="line">  <span class="comment">// 里面存储着所有与当前 key 相关联的副作用函数：effects</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="comment">// 如果 deps 不存在，同样新建一个 Set 并与 key 关联</span></span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将当前激活的副作用函数添加到“桶”里</span></span><br><span class="line">  deps.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">  <span class="comment">// 将其添加到 activeEffect.deps 数组中</span></span><br><span class="line">  activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(deps)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 set 拦截函数内调用 trigger 函数触发变化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">trigger</span> = (<span class="params">target, key</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 根据 target 从桶中取得 depsMap，即 key --&gt; effects</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 根据 key 取得所有副作用函数 effects</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="comment">// 拷贝原有的 Set 数据，避免无限循环的问题</span></span><br><span class="line">  <span class="keyword">const</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</span></span><br><span class="line">    <span class="keyword">if</span> (effectFn!== activeEffect) &#123;</span><br><span class="line">      effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果一个副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递</span></span><br><span class="line">    <span class="keyword">if</span> (effectFn.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;</span><br><span class="line">      effectFn.<span class="property">options</span>.<span class="title function_">scheduler</span>(effectFn)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则直接执行副作用函数（之前的默认行为）</span></span><br><span class="line">      <span class="title function_">effectFn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理数据</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 拦截读取操作</span></span><br><span class="line">  <span class="title function_">get</span> (target, key) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, key)</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截设置操作</span></span><br><span class="line">  <span class="title function_">set</span> (target, key, newVal) &#123;</span><br><span class="line">    <span class="comment">// 设置属性值</span></span><br><span class="line">    target[key] = newVal</span><br><span class="line">    <span class="title function_">trigger</span>(target, key)</span><br><span class="line">    <span class="comment">// 返回 true 代表设置操作成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// computed 计算属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">computed</span> = getter =&gt; &#123;</span><br><span class="line">  <span class="comment">// value 用来缓存上一次计算的值</span></span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="comment">// dirty 标志，用来标识是否需要重新计算值，为 true 则意味着“脏”，需要计算</span></span><br><span class="line">  <span class="keyword">let</span> dirty = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">scheduler</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">        <span class="comment">// 当读取 value 时，手动调用 trigger 函数触发响应</span></span><br><span class="line">        <span class="title function_">trigger</span>(obj, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        <span class="comment">// 当调度器调度副作用函数时，将 dirty 设置为 true</span></span><br><span class="line">        dirty = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="comment">// 当读取 obj.value 时才执行 effectFn</span></span><br><span class="line">    get <span class="title function_">value</span> () &#123;</span><br><span class="line">      <span class="comment">// 只有“脏”时才计算值，并将得到的值缓存到 value 中</span></span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = <span class="title function_">effectFn</span>()</span><br><span class="line">        <span class="comment">// 将 dirty 设置为 false，下一次访问直接使用缓存到 value 中的值</span></span><br><span class="line">        dirty = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当读取 value 时，手动调用 track 函数进行追踪</span></span><br><span class="line">      <span class="title function_">track</span>(obj, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 watch 函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">watch</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制副作用函数执行的时机</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">effect(</span></span><br><span class="line"><span class="comment">  () =&gt; &#123;</span></span><br><span class="line"><span class="comment">    console.log(obj.foo)</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    // 调度器 scheduler 是一个函数</span></span><br><span class="line"><span class="comment">    scheduler (fn) &#123;</span></span><br><span class="line"><span class="comment">      // 将副作用函数添加到宏任务队列中</span></span><br><span class="line"><span class="comment">      setTimeout(fn)</span></span><br><span class="line"><span class="comment">      // 或者使用微任务队列</span></span><br><span class="line"><span class="comment">      // p.then(fn)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制副作用函数执行的次数，如当前宏任务对同一个响应数据的修改，只会执行一次副作用函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">// 使用 Set 数据结构，保证任务只会执行一次</span></span><br><span class="line"><span class="comment">const jobQueue = new Set()</span></span><br><span class="line"><span class="comment">// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列中</span></span><br><span class="line"><span class="comment">const p = Promise.resolve()</span></span><br><span class="line"><span class="comment">// 使用一个标志位，标识当前是否正在刷新队列</span></span><br><span class="line"><span class="comment">let isFlushing = false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const flushJon = () =&gt; &#123;</span></span><br><span class="line"><span class="comment">  // 等待当前的微任务队列清空</span></span><br><span class="line"><span class="comment">  if (!isFlushing) &#123;</span></span><br><span class="line"><span class="comment">    isFlushing = true</span></span><br><span class="line"><span class="comment">    p.then(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">      jobQueue.forEach(job =&gt; job())</span></span><br><span class="line"><span class="comment">    &#125;).finally(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">      isFlushing = false</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">effect(</span></span><br><span class="line"><span class="comment">  () =&gt; &#123;</span></span><br><span class="line"><span class="comment">    console.log(obj.foo)</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    // 调度器 scheduler 是一个函数</span></span><br><span class="line"><span class="comment">    scheduler (fn) &#123;</span></span><br><span class="line"><span class="comment">      // 将副作用函数添加到微任务队列中</span></span><br><span class="line"><span class="comment">      jobQueue.add(fn)</span></span><br><span class="line"><span class="comment">      flushJon()</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E4%B9%A6%E7%B1%8D/Vue%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/04%20%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0/" data-id="cmd8fcqep000r64g5f68f0foq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="tag">Vue.js 设计与实现</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB/" rel="tag">阅读</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/07/18/%E4%B9%A6%E7%B1%8D/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/%E7%AC%94%E8%AE%B01/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          人月神话阅读笔记
        
      </div>
    </a>
  
  
    <a href="/2025/07/18/%E4%B9%A6%E7%B1%8D/Vue%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/03%20Vue.js%203%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Vue.js 设计与实现 - 03 Vue.js 3 的设计思路</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SCSS/" rel="tag">SCSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="tag">Vue.js 设计与实现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue3/" rel="tag">Vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/" rel="tag">人月神话</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">前端工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95/" rel="tag">备忘录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" rel="tag">开发日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" rel="tag">设计原则和编程技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB/" rel="tag">阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E8%AE%B0/" rel="tag">随记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 19px;">JavaScript</a> <a href="/tags/SCSS/" style="font-size: 10px;">SCSS</a> <a href="/tags/Vue/" style="font-size: 13px;">Vue</a> <a href="/tags/Vue-js-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" style="font-size: 16px;">Vue.js 设计与实现</a> <a href="/tags/Vue3/" style="font-size: 10px;">Vue3</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/" style="font-size: 11px;">人月神话</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 10px;">其他</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 15px;">前端工程化</a> <a href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95/" style="font-size: 11px;">备忘录</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" style="font-size: 10px;">开发日志</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">架构</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">框架</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 12px;">设计原则和编程技巧</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 17px;">设计模式</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 14px;">转载</a> <a href="/tags/%E9%98%85%E8%AF%BB/" style="font-size: 17px;">阅读</a> <a href="/tags/%E9%9A%8F%E8%AE%B0/" style="font-size: 10px;">随记</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 18px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">七月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/18/%E9%9A%8F%E8%AE%B0/2025%E5%B9%B407%E6%9C%8818%E6%97%A5%E9%9A%8F%E8%AE%B0/">2025年07月18日随记</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/">输入URL到渲染全面梳理中-页面渲染篇</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/">输入URL到渲染全面梳理上-网络通信篇</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93/">输入URL到渲染全面梳理下-总结篇</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTTP%20%E7%AF%87/">收集的面试题 - HTTP 篇</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 havebear<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>