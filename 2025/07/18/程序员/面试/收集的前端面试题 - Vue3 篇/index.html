<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>收集的前端面试题 - Vue3 篇 | Have Bear</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="谈谈对 MVVM 的理解MVVM 是 Model-View-ViewModel 的锁鞋，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 代表数据模型，View 代表 UI 组件，ViewModel 是 VIew 和 Model 的桥梁，数据会绑定到 ViewModel 上，并自动将数据渲染到页面中，视图变化的时候会通知 ViewModel 更新数据。 Vu">
<meta property="og:type" content="article">
<meta property="og:title" content="收集的前端面试题 - Vue3 篇">
<meta property="og:url" content="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue3%20%E7%AF%87/index.html">
<meta property="og:site_name" content="Have Bear">
<meta property="og:description" content="谈谈对 MVVM 的理解MVVM 是 Model-View-ViewModel 的锁鞋，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 代表数据模型，View 代表 UI 组件，ViewModel 是 VIew 和 Model 的桥梁，数据会绑定到 ViewModel 上，并自动将数据渲染到页面中，视图变化的时候会通知 ViewModel 更新数据。 Vu">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-18T06:03:17.130Z">
<meta property="article:modified_time" content="2025-07-18T06:03:17.131Z">
<meta property="article:author" content="havebear">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Have Bear" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Have Bear</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://havebear.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-程序员/面试/收集的前端面试题 - Vue3 篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue3%20%E7%AF%87/" class="article-date">
  <time datetime="2025-07-18T06:03:17.130Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      收集的前端面试题 - Vue3 篇
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h2 id="谈谈对-MVVM-的理解"><a href="#谈谈对-MVVM-的理解" class="headerlink" title="谈谈对 MVVM 的理解"></a>谈谈对 MVVM 的理解</h2><p>MVVM 是 Model-View-ViewModel 的锁鞋，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 代表数据模型，View 代表 UI 组件，ViewModel 是 VIew 和 Model 的桥梁，数据会绑定到 ViewModel 上，并自动将数据渲染到页面中，视图变化的时候会通知 ViewModel 更新数据。</p>
<h2 id="Vue3-对比-Vue2-有哪些优势"><a href="#Vue3-对比-Vue2-有哪些优势" class="headerlink" title="Vue3 对比 Vue2 有哪些优势"></a>Vue3 对比 Vue2 有哪些优势</h2><p>性能更好，打包体积更小，更好的 ts 支持，更好的代码组织，更好的逻辑抽离，更多的新功能</p>
<h2 id="Vue3-的新特性"><a href="#Vue3-的新特性" class="headerlink" title="Vue3 的新特性"></a>Vue3 的新特性</h2><ul>
<li>性能提升<ul>
<li>响应式性能提升，由原来的 <code>Object.defineProperty</code> 改为 <code>ES6</code> 的 Proxy，速度更快</li>
<li>重写了 <code>Vdom</code>，diff 算法优化，增加了静态标记</li>
<li>进行了模板编译优化，静态提升，不参与更新的元素只被创建一次</li>
<li>更高效的组件初始化</li>
</ul>
</li>
<li>更好的支持 TypeScript<ul>
<li>Vue2 选用 Flow 做类型检查来避免一些因类型问题导致的错误，但是 Flow 对于一些复杂场景类型的检查，支持得并不好</li>
<li>Vue3 抛弃了 Flow，使用 TypeScript 重构了整个项目</li>
<li>TypeScript 提供了更好的类型检查，能支持复杂的类型推断</li>
</ul>
</li>
<li>新增 Composition API<ul>
<li>提高代码逻辑的复用性和维护性，同时代码压缩性更强</li>
<li>定义 methods、watch、computed、data 都放在了 setup() 函数中</li>
<li>setup() 函数会在 created() 之前执行，beforeCreate &gt; setup &gt; cteated</li>
</ul>
</li>
<li>新增组件<ul>
<li>Fragment 不再限制 template 只有一个根节点</li>
<li>Teleport 传送门，允许我们将控制的内容传送到任意 DOM中，就是指定组件挂载位置，如通过 #id</li>
<li>Suspense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验</li>
</ul>
</li>
<li>Tree-shaking，支持摇树优化<br>会将不需要的模块修剪掉，打包真正需要的模块，优化后的项目体积只有原来的一般，加载速度会更快。</li>
<li>Custom Renderer API，自定义渲染器<br>实现 DOM 的方式进行 WebGL 编程</li>
</ul>
<h2 id="Vue3-和-Vue2-的区别"><a href="#Vue3-和-Vue2-的区别" class="headerlink" title="Vue3 和 Vue2 的区别"></a>Vue3 和 Vue2 的区别</h2><ul>
<li>源码组织方式变化，使用 TypeScript 重写</li>
<li>支持 Compsition API，基于函数的 API，更加灵活地组织组件逻辑（Vue2 是 Options API）</li>
<li>响应式系统提升，从 defineProperty 到 Proxy，可监听动态新增删除属性以及数组的变化</li>
<li>编译优化，Vue2 通过标记静态根节点优化 diff，Vue3 标记和提升所有静态根节点，diff 的时候只需要对比动态节点内容</li>
<li>打包体积优化，移除了不常用的 API（inline-template、filter）</li>
<li>生命周期的变化，使用 setup 代替了之前的 beforeCreate 和 created</li>
<li>Vue3 的 template 模板支持多个根标签</li>
<li>更多</li>
</ul>
<h2 id="Vue3-性能提升主要是通过哪些方面体现的"><a href="#Vue3-性能提升主要是通过哪些方面体现的" class="headerlink" title="Vue3 性能提升主要是通过哪些方面体现的"></a>Vue3 性能提升主要是通过哪些方面体现的</h2><ul>
<li><strong>编译阶段优化</strong><br>回顾 Vue2，我们知道每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据 property 记录为依赖，当依赖发生变化，触发 setter，则会通知 watcher，从而使关联的组件重新渲染，因此，Vue3 在编译阶段做了进一步的优化：<ul>
<li><strong>diff 算法优化</strong><br>增加了静态标记，其作用是为了在发生变化的地方添加一个 flag 标记，下次发生变化时直接在该处进行比较。</li>
<li><strong>静态提升</strong><br>Vue3 对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接服用。避免了重复的创建操作，优化内存。</li>
<li><strong>事件监听缓存</strong><br>默认情况下绑定事件行为会被视为动态绑定（未开启事件监听器缓存），所以每次都会追踪它的变化，开启事件侦听器缓存后，没有了静态标记，下次 diff 算法的时候直接使用。</li>
<li><strong>SSR 优化</strong><br>当静态内容大到一定量级的时候，会用 createStaticVNode 方法在客户端生成一个 static node，这些静态 node会被直接 innerHTML，就不需要创建对象，然后根据对象渲染</li>
</ul>
</li>
<li><strong>源码体积</strong><br>相比 Vue2，Vue3 整体体积变小了，移除了一些不常用的 API，最重要的是增加了 Treeshaking，任何一个函数，如 ref、reactive、computed 等，仅仅在用到的时候才打包，没用到的模块会被移除，减小体积。</li>
<li><strong>响应式系统</strong><br>Vue2 采用 defineProperty 来实现数据劫持，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter 实现响应式。<br>Vue3 采用 Proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听，不需要深度遍历，另外还解决了 2 中的不足：<ul>
<li>可以监听动态属性的添加</li>
<li>可以监听数组的索引和数组的 length 属性</li>
<li>可以监听删除属性</li>
</ul>
</li>
</ul>
<h2 id="Vue3-的响应式原理"><a href="#Vue3-的响应式原理" class="headerlink" title="Vue3 的响应式原理"></a>Vue3 的响应式原理</h2><h3 id="Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢"><a href="#Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢" class="headerlink" title="Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢?"></a>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢?</h3><p>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。</p>
<h3 id="监测数组的时候可能触发多次get-set，那么如何防止触发多次呢？"><a href="#监测数组的时候可能触发多次get-set，那么如何防止触发多次呢？" class="headerlink" title="监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？"></a>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</h3><p>我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p>
<h2 id="v-model-双向绑定的原理是什么"><a href="#v-model-双向绑定的原理是什么" class="headerlink" title="v-model 双向绑定的原理是什么"></a>v-model 双向绑定的原理是什么</h2><p>v-model 本质上是一个语法糖，可以看成是 value + input 方法的组合。可以通过 model 属性的 prop 和 event 属性来进行自定义。原生的 v-model 会根据标签的不同生成不同的事件和属性。</p>
<h2 id="Options-API-的生命周期"><a href="#Options-API-的生命周期" class="headerlink" title="Options API 的生命周期"></a>Options API 的生命周期</h2><ul>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>onMounted</li>
<li>beforeUpdate</li>
<li>onUpdated</li>
<li>beforeUnmount</li>
<li>onUnmounted</li>
<li>onActivated</li>
<li>onDeactivated</li>
<li>onErrorCaptured</li>
</ul>
<h2 id="Composition-API-和-Options-API"><a href="#Composition-API-和-Options-API" class="headerlink" title="Composition API 和 Options API"></a>Composition API 和 Options API</h2><p>Options API 是一种基于对象的 API，用组件的选项（data、computed、methods、watch）组织逻辑在大多数情况下是可行的，然后当组件变得复杂，导致对应属性的列表也会增加，可能会导致组件难以理解和阅读。</p>
<p>Composition API 是一种函数式的 API，组件根据逻辑功能来组织，一个功能定义的所有 API 会放在一起（更加的 高内聚、低耦合）</p>
<p>Composition API 相对于 Options API 有以下优点：</p>
<ul>
<li>逻辑组织<ul>
<li>Options API 在处理大型组件时，内部逻辑点容易碎片化，可能同时存在于各选项中（data、computed、methods、watch），我们必须不断地“跳转”相关代码的选项块，这种碎片化使得理解和维护复杂组件变得困难。</li>
<li>Composition API 把某个逻辑相关代码全部放在一个函数里。</li>
</ul>
</li>
<li>逻辑复用<br>在 Vue2 中，使用混入函数 mixin 会存在两个非常明显的问题，命名冲突和数据来源不清晰，而 Composition API 可以通过编写多个 hooks 函数来实现逻辑复用。</li>
</ul>
<h2 id="reactive、ref-、toRef-和-toRefs"><a href="#reactive、ref-、toRef-和-toRefs" class="headerlink" title="reactive、ref 、toRef 和 toRefs"></a>reactive、ref 、toRef 和 toRefs</h2><ul>
<li>ref，函数可以接受基本数据类型和引用数据类型，创建的响应式数据在模板中可以直接使用，在 JavaScript 中使用需要通过 .value 的形式。</li>
<li>reactive，函数只能接受引用数据类型。</li>
<li>toRef，函数可以把响应式对象中的某个属性转换成 ref 对象。</li>
<li>toRefs，将一个响应式对象转为普通对象，对象的每一个属性都转换成 ref 对象。</li>
</ul>
<h2 id="script-setup"><a href="#script-setup" class="headerlink" title="script setup"></a>script setup</h2><p>Vue3 的语法糖，简化了组合式 API 的写法</p>
<ul>
<li>属性和方法无需返回，可直接使用</li>
<li>引入的组件会自动注册，无需通过 components 手动注册</li>
<li>使用 defineProps 接收父组件传递的值</li>
<li>useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件</li>
<li>默认不会对外暴露任何属性，如果有需要可使用 definExpose</li>
</ul>
<h3 id="在-setup-中如何获取组件实例"><a href="#在-setup-中如何获取组件实例" class="headerlink" title="在 setup 中如何获取组件实例"></a>在 setup 中如何获取组件实例</h3><p>使用 getCurrentInstance() 方法来获取组件实例，该方法返回一个对象，对象包含了组件实例及其相关信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="title function_">getCurrentInstance</span>()</span><br></pre></td></tr></table></figure>

<h2 id="v-if-和-v-for-的优先级"><a href="#v-if-和-v-for-的优先级" class="headerlink" title="v-if 和 v-for 的优先级"></a>v-if 和 v-for 的优先级</h2><p>在 Vue2 中 v-for 优先级更高，但在 Vue3 中 v-if 优先级更高。</p>
<h2 id="watch-和-watchEffect"><a href="#watch-和-watchEffect" class="headerlink" title="watch 和 watchEffect"></a>watch 和 watchEffect</h2><p>watch 和 watchEffect 都是监听器，watchEffect 是一个副作用函数，它们之间的区别：</p>
<ul>
<li>watch 需要指定监视的数据源和回调函数，watchEffect，不需要指定监视的数据源，它会自动追踪响应式数据的变化，回调函数中用到了哪个数据，就监视哪个数据</li>
<li>watch 可以访问到旧值和新值，watchEffect 只能访问到新值</li>
<li>watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 会立即执行一次，这一点通过 watch 的配置项 immediate 可以改变</li>
<li>watchEffect 有点像 computed<ul>
<li>但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值</li>
<li>而 watchEffect 注重的是过程（回调函数的执行），所以不用写返回值</li>
</ul>
</li>
<li>watch 与 Vue2 中的 watch 配置功能一致，但需要注意<ul>
<li>监视 reactive 定义的响应式数据时，oldValue 无法正确获取，且会强制开启深度检测（deep 配置失效）</li>
<li>监视 reactive 定义的响应式数据中某个属性时，deep 配置有效</li>
</ul>
</li>
</ul>
<h2 id="Vue2-Vue3-组件通信方式"><a href="#Vue2-Vue3-组件通信方式" class="headerlink" title="Vue2/Vue3 组件通信方式"></a>Vue2/Vue3 组件通信方式</h2><p>Vue3 通信方式</p>
<ul>
<li>props</li>
<li>$emit</li>
<li>expose/ref</li>
<li>$attrs</li>
<li>v-model</li>
<li>provide/inject</li>
<li>Vuex/pinia</li>
<li>mitt</li>
</ul>
<p>Vue2 通信方式</p>
<ul>
<li>props</li>
<li>$emit/v-on</li>
<li>.sync</li>
<li>v-model</li>
<li>ref</li>
<li>children/parent</li>
<li>attrs/listeners</li>
<li>provide/inject</li>
<li>eventBus</li>
<li>Vuex</li>
<li>$root</li>
<li>slot</li>
</ul>
<!-- # 收集的前端面试题 - Vue3 篇

## Vue3 有什么更新

- 响应式系统
  - Proxy 代替 Object.defineProperty
  - 基于 ES6 Map 代替 Object
  - 基于 ES6 Set 代替 Array
  - 基于 ES6 WeakMap 代替 Object
  - 基于 ES6 WeakSet 代替 Array -->



<ul>
<li>Vue 的生命周期有哪些，以及每个生命周期做了什么</li>
<li>Vue 的响应式原理是什么，Vue3 中是如何实现的</li>
<li>Vue3 和 Vue2 有什么区别</li>
<li>谈谈对 MVVM 的理解</li>
<li>在 Vue2 中如何检测数据的变化</li>
<li>v-model 双向绑定的原理是什么</li>
<li>Vue2 和 Vue3 渲染器的 diff 算法分别说一下</li>
<li>Vue2/3 组件通信方式</li>
<li>Vue 的路由实现，hash 和 history 路由实现原理</li>
<li>说一下 v-if 和 v-show 的区别</li>
<li>keep-alive 的常用属性和实现原理</li>
<li>nextTick 的作用是什么，实现原理是什么</li>
<li>说一下 Vue SSR 的实现原理</li>
<li>Vue 组件的 data 为什么必须是函数</li>
<li>说一下 Vue 的 computed 的实现原理</li>
<li>说一下 Vue complier 的实现原理</li>
<li>Vue 和 React 的区别</li>
<li>说一下 watch 与 computed 的区别是什么，以及对应的使用场景</li>
<li>Vue 有哪些修饰符</li>
<li>如何实现 Vue 项目的性能优化</li>
<li>Vue 中的 SPA 应用如何优化首屏加载速度</li>
<li>Vue 中的 key 的作用是什么</li>
<li>你的接口请求一般放在哪个生命周期中？为什么</li>
<li>Vue3 对比 Vue2 有什么优势</li>
<li>描述 Vue3 的生命周期</li>
<li>如何看待 Composition API 和 Options API</li>
<li>Vue3 有什么更新</li>
<li>Proxy 和 Object.defineProperty 的区别</li>
<li>Vue3 升级了哪些重要功能</li>
<li>Vue2 和 Vue3 核心 diff 算法区别</li>
<li>Vue3 为什么比 Vue2 快</li>
<li>Vue3 如何实现响应式</li>
<li>Vue3 编译做了哪些优化</li>
<li>watch 和 watchEffect 的区别</li>
<li>请介绍 Vue3 中的 Teleport（瞬移） 组件，是什么以及使用场景</li>
<li>如何理解 reactive、ref、toRef 和 toRefs</li>
<li>谈谈 pinia</li>
<li>EventBus 和 mitt 的区别</li>
<li>script setup 是什么</li>
<li>v-if 和 v-for 的优先级</li>
<li>setup 中如何获取组件实例</li>
<li>Vue3 中的 Suspense 是什么，如何是用它来处理异步组件</li>
<li>Vue3 性能提升主要是通过什么方面体现的</li>
<li>Vue3 为什么要用 Proxy API 替代 defineProperty API</li>
<li>Vue3 中的 Treeshaking 特性</li>
<li>说说你对 SPA 单页面的理解，它的优缺点分别是什么</li>
<li>v-show 与 v-if 有什么区别</li>
<li>Class 与 Style 如何动态绑定</li>
<li>怎么理解 Vue 的单向数据流</li>
<li>computed 和 watch 的区别和运用的场景</li>
<li>直接给一个数组项赋值，Vue 能检测到变化吗</li>
<li>谈谈你对 Vue 生命周期的理解</li>
<li>Vue 的父组件和子组件生命周期钩子函数执行顺序</li>
<li>在哪个生命周期内调用异步请求</li>
<li>在什么阶段才能访问操作DOM</li>
<li>父组件可以监听到子组件的生命周期吗</li>
<li>谈谈你对 keep-alive 的了解</li>
<li>组件中 data 为什么是一个函数</li>
<li>v-model 的原理</li>
<li>Vue 组件间通信有哪几种方式</li>
<li>你使用过 Vuex 吗</li>
<li>使用过 Vue SSR 吗？说说 SSR</li>
<li>vue-router 路由模式有几种</li>
<li>能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</li>
<li>什么是 MVVM</li>
<li>Vue 是如何实现数据双向绑定的</li>
<li>Vue 框架怎么实现对象和数组的监听</li>
<li>Proxy 与 Object.defineProperty 优劣对比</li>
<li>Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</li>
<li>虚拟 DOM 的优缺点</li>
<li>虚拟 DOM 实现原理</li>
<li>Vue 中的 key 有什么作用</li>
<li>你有对 Vue 项目进行哪些优化</li>
<li>对于即将到来的 vue3.0 特性你有什么了解的吗</li>
<li>说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue3%20%E7%AF%87/" data-id="cmd8fcqez002r64g54ba972lk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue2%20%E7%AF%87/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          收集的前端面试题 - Vue3 篇
        
      </div>
    </a>
  
  
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20TypeScript%20%E7%AF%87/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">收集的前端面试题 - TypeScript 篇</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SCSS/" rel="tag">SCSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="tag">Vue.js 设计与实现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue3/" rel="tag">Vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/" rel="tag">人月神话</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">前端工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95/" rel="tag">备忘录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" rel="tag">开发日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" rel="tag">设计原则和编程技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB/" rel="tag">阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E8%AE%B0/" rel="tag">随记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 19px;">JavaScript</a> <a href="/tags/SCSS/" style="font-size: 10px;">SCSS</a> <a href="/tags/Vue/" style="font-size: 13px;">Vue</a> <a href="/tags/Vue-js-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" style="font-size: 16px;">Vue.js 设计与实现</a> <a href="/tags/Vue3/" style="font-size: 10px;">Vue3</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/" style="font-size: 11px;">人月神话</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 10px;">其他</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 15px;">前端工程化</a> <a href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95/" style="font-size: 11px;">备忘录</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" style="font-size: 10px;">开发日志</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">架构</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">框架</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 12px;">设计原则和编程技巧</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 17px;">设计模式</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 14px;">转载</a> <a href="/tags/%E9%98%85%E8%AF%BB/" style="font-size: 17px;">阅读</a> <a href="/tags/%E9%9A%8F%E8%AE%B0/" style="font-size: 10px;">随记</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 18px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">七月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/18/%E9%9A%8F%E8%AE%B0/2025%E5%B9%B407%E6%9C%8818%E6%97%A5%E9%9A%8F%E8%AE%B0/">2025年07月18日随记</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/">输入URL到渲染全面梳理中-页面渲染篇</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/">输入URL到渲染全面梳理上-网络通信篇</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93/">输入URL到渲染全面梳理下-总结篇</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTTP%20%E7%AF%87/">收集的面试题 - HTTP 篇</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 havebear<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>