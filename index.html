<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Have Bear</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端、博客、总结、资源">
<meta property="og:type" content="website">
<meta property="og:title" content="Have Bear">
<meta property="og:url" content="http://havebear.com/index.html">
<meta property="og:site_name" content="Have Bear">
<meta property="og:description" content="前端、博客、总结、资源">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="havebear">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Have Bear" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Have Bear</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://havebear.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-随记/2025年07月18日随记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E9%9A%8F%E8%AE%B0/2025%E5%B9%B407%E6%9C%8818%E6%97%A5%E9%9A%8F%E8%AE%B0/" class="article-date">
  <time datetime="2025-07-18T06:04:45.706Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/18/%E9%9A%8F%E8%AE%B0/2025%E5%B9%B407%E6%9C%8818%E6%97%A5%E9%9A%8F%E8%AE%B0/">2025年07月18日随记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>时隔很久，重新拾起博客，感叹自己生活、工作和想法的巨变，总要留下些什么，今年是 ai agent 大爆发的一年，去年还见大家面对 ai 的困惑，现今包括我已经在方方面面的使用 ai，关于职业的未来，先把现在做好，积极拥抱新事物，不断成长和学习。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E9%9A%8F%E8%AE%B0/2025%E5%B9%B407%E6%9C%8818%E6%97%A5%E9%9A%8F%E8%AE%B0/" data-id="cmd8fcqel000564g57cqy6c05" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E8%AE%B0/" rel="tag">随记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-程序员/面试/输入URL到渲染全面梳理中-页面渲染篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/" class="article-date">
  <time datetime="2025-07-18T06:03:17.133Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/">输入URL到渲染全面梳理中-页面渲染篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接上文，上文我们讲了网络通信的部分，详细请看 「一道面试题」输入URL到渲染全面梳理上-网络通信篇 ，那么该说说页面渲染的流程了，也就是当输入一个URL拿到了页面后，浏览器怎么解析，怎么呈现</p>
        
          <p class="article-more-link">
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/" data-id="cmd8fcqf1003864g567h6hlok" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-程序员/面试/输入URL到渲染全面梳理上-网络通信篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/" class="article-date">
  <time datetime="2025-07-18T06:03:17.132Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/">输入URL到渲染全面梳理上-网络通信篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从输入 URL 到页面渲染发生了什么？比如在浏览器输入了 <a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> 后浏览器是怎么把最终的页面呈现，这是一个非常经典的面试题，不管是大公司还是小公司甚至前端或后端的面试中命中率都极高，因为涉及到的知识点和可挖掘的地方比较多，而且这中间几乎每一步都是可以优化的。文章很长，原作者分成了三个篇幅，分别从 网络通信 和页面渲染 两个方面描述</p>
        
          <p class="article-more-link">
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/" data-id="cmd8fcqf0003364g5b43wcbkh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-程序员/面试/输入URL到渲染全面梳理下-总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2025-07-18T06:03:17.132Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93/">输入URL到渲染全面梳理下-总结篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>此文是一道面试题，又不仅仅是一道面试题，你会发现，这题不论大厂小厂，都会问，为什么<br>因为它足够经典，连续写了三篇帖子，每篇都上万字，依然感觉不够细，涉及的点真的很考验一个人的知识覆盖率，还是多方面的考验，如果让我来面试的话，我觉得完全可以通过这一道题挖掘出面试者的基础知识储备量，延展性更是超强<br>SO，答好它可以让面试官眼前一亮，让你与众不同<br>此文是总结篇，没有看过前两篇的小伙伴建议先看看，然后自己总结总结，再来看这篇，因为前两文是为了能够看懂此文才写的<br>「一道面试题」输入URL到渲染全面梳理上-网络通信篇<br>「一道面试题」输入URL到渲染全面梳理中-页面渲染篇<br>如果你都看过了，那就来一块总结吧，首先，还请为我的疯狂码字点个赞再看哦，最近打字速度都快了不少 😄<br>回顾？<br>本来这块儿会简单回顾下前两文知识点再进行总结的，还有一个思维导图，原本已经写的差不多了，大概有个1万字了，后来写着写着被我删了大半重新写了<br>因为某天心血来潮，想把整篇文章换成一面试的问答帖，写帖嘛，我比较喜欢 认真且随心所欲 ，就删了重来了，所以此文才会慢了些<br>下文会以一个面试官和面试者问答的过程来描述这些个问题，主体问题答完之后还会有一些比较常见的主体发散的问题，最近得空看完了电视剧 鬓边不是海棠红 ，看的说话都有点被带跑偏了，用剧中 老北京腔 来说就是 得，您瞧好吧！😄 ，好了，调侃完毕，开始正经了，干巴巴的万字小文来了，做好准备哦<br>首先请带入你自己，你就是一个面试者，仔细看每道题，先静心想一会，然后在心中回答，最后再看总结的答案 ( 此答案也不一定对，个人感悟，只给大家做参考，也望大家给予补充或指正 )<br>问(主体)：输入URL到页面渲染都经历了什么？<br>个人觉得 ，不要急着回答，先思考30秒，在心中形成一个大致步骤的轮廓，先概括，然后再慢慢道来，注意节奏，中间也可以短暂停顿思考，面试官不会因为你想了一会就 pass 掉你，相反，你直接脱口而出一堆内容，会让面试官觉得你像是背课文<br>对于主体问题，写了两种回答，觉得需要注意两点来选择性回答，至少我这么觉得<br>面试官的状态<br>大致判断面试官是一个什么样的人，注意面试官这个人的状态，这很重要，通过对面试官当时状态的判断来决定精简回答或是轰炸式回答，这里的轰炸式回答不是说越多越好，说的是我们在回答的时候顺带牵出一些知识点来证明我们的知识量，但是不管怎样回答都要回答在点上，不要认为答得越多越好就扯一些有的没的，这大概就是察言观色吧<br>你的状态<br>你的状态就比较容易理解了，如果你对一些知识点掌握不牢靠或有些紧张，这个时候就不要死撑还争取回答的面面俱到了 (面试官面前不太懂硬装做什么都懂，容易引起些许反感)，尽量精简，把你熟的地方多说一点，这样可以对面试官进行一个暗示引导，然后等待让面试官发散问你，通常你哪里说的多，面试官就会往哪个方向发散，如果你足够自信，那就尽情说好了，不在意他的发散，只要不说没用的就👌，绝大多数面试官对于这种情况应该都会喜欢<br>一本正经的轰炸式回答<br>面试官你好，这个问题是一个经典问题，我业余时间也有仔细阅读过一些相关书籍，做过一些总结，因为涉及到的知识点很多，所以可能会花一些时间，如果中间您有什么问题或者我的回答有不正确，还请您随时打断我，为我指出错误，谢谢<br>我觉得从URL输入到页面渲染大体上可以分为网络通信 和 页面渲染 两个阶段<br>首先是网络通信阶段，在互联网中网络设备之间的通信都会遵循 TCP/IP四层协议，通过 TCP/IP 网络分层顺序与对方进行通信，分层由高到低分别为：应用层、传输层、网络层、数据链路层，我们浏览器输入URL也就是发送端会从 应用层 往下走，接收端也就是服务器会从 数据链路层 往上走，通常我们会用五层协议来解释，数据链路层这一层会分成物理层和数据链路层两层<br>浏览器输入URL<br>输入URL按下回车后，就进入了 应用层 开始往下走，浏览器会开一个线程来处理，先对URL进行解析，一般包括 ( 协议头、主机域名或IP地址、端口号、请求路径、查询参数、hash等等 )，然后打开网络线程发出一个完整的请求<br>应用层DNS解析域名<br>这其中DNS解析，也就是 域名或IP解析 是因为我们输入的URL通常都是一个域名，计算机不认识域名只知道IP，所以需要DNS解析通过域名查询得到对应IP，对于DNS解析时</p>
<p>首先会查看浏览器DNS缓存<br>没有的话就查询计算机本地DNS缓存<br>还没有就询问递归式DNS服务器（就是网络提供商，一般这个服务器都会有自己的缓存，所以IP查询大多都在这里完成）<br>如果依然没有缓存，那就需要通过 根域名服务器 和 TLD域名服务器 再到对应的 权威DNS服务器 找记录，并缓存到 递归式服务器，然后 递归服务器 再将记录返回给本地</p>
<p>应用层客户端发送HTTP请求<br>IP地址有了，应用层的客户端想看页面，就会发一个 HTTP 请求，HTTP 请求分为 请求报头 和 请求主体 ，请求主体就是客户端要发送给服务器或者服务器返回给客户端的内容，请求报头比较重要，包含通信方式也就是请求方法 (POST / GET / INPUT / DELETE等)、URI、协议版本号以及请求头部方法（Accept、Cache-Control…）<br>传输层TCP传输报文<br>应用层 发送了一个请求后，为了传输方便，在 传输层 会把从 应用层 接收到的数据 ( 就是那个HTTP请求报文 ) 进行分割，并为每个报文编号后再转发给 网络层，编号就是方便服务器接收时能准确地还原报文信息，这里用到了我们常说的 TCP协议<br>TCP协议 会通过 三次握手 保证传输的安全可靠，也可以这样说，客户端在 传输层 开始和服务器通过 三次握手 建立 TCP/IP 连接<br>所谓的 三次握手 ，就是发送端先发送一个带有 SYN ( synchronize ) 标志的数据包给接收端，在一定的延迟时间内等待接收端的回复，接收端收到数据包后，传回一个带有 SYN / ACK 标志的数据包以表示传达确认信息，接收方收到后再发送一个带有 ACK 标志的数据包给接收端以表示握手成功，在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止<br>也就是上一文说的</p>
<p>小李 (客户端)：您好，您是xx的面试官吗？</p>
<p>面试官 (服务端)：嗯嗯，是的，你是昨天投简历的小李吗？</p>
<p>小李 (客户端)：嗯嗯，是的，我是</p>
<p>网络层IP协议查询MAC地址<br>建立连接后 网络层 IP协议会查询 MAC地址 进行数据包的传输<br>通俗来说，IP协议 负责把各种数据包传送给接收方，因为要保证确实能传输到对方，所以需要确定接收方的 MAC地址 也就是我们说的物理地址，IP地址 可以和 MAC地址 通过映射表一一配对上，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的，而 IP 到 MAC 的解析过程则依赖于 ARP协议，它可以根据通信方的 IP地址 反查出对应的 MAC地址<br>因为一般通信双方是无法直接进行通信的（除非在同一局域网），会经过多台计算机或路由器来进行中转，所以也就需要 ARP 来一路确认下一个中转站，协助数据包的传输<br>数据到达数据链路层<br>找到对方的 MAC地址 后，就会将数据发送到 数据链路层传输，到此客户端发送请求阶段就结束了<br>服务器接收数据<br>而后接收端的服务器在 数据链路层 接收到数据包，再通过相反的方式将数据一层一层的还原回 应用层 ，这过程中包括在运输层那里通过TCP协议将分段的数据包重新组成原来的HTTP请求报文<br>请求到了后台服务器，一般来说会有统一的验证，如安全验证、跨域验证等，验证未通过就直接返回相应的HTTP报文，验证通过后，就会进入后台代码，此时程序收到请求，然后会执行对应的操作<br>如果浏览器访问过，且缓存上有对应的资源，就会与服务器最后修改时间对比，一致便返回304，告诉浏览器可使用本地缓存<br>服务器响应请求<br>服务器接收到客户端发送的HTTP请求后，会查找客户端请求的资源，并返回响应报文<br>另外现在很多网站都会有重定向功能，比如请求域名省去了 www.，它会给你重定向来添加上，这也就意味着第一次请求 HTML 的过程中我们是需要发起两次请求的<br>这样做的原因在于搜索引擎会认为 <a target="_blank" rel="noopener" href="http://www.xxx.com/">www.xxx.com</a> 和 xxx.com 是两个网站，从而造成网站排名下降，还有如果两个地址都有打开过，会造成多余 ( 双倍 ) 的浏览器缓存<br>服务器返回相应文件<br>请求成功后，服务器会返回相应的网页，浏览器接收到响应成功的报文后便开始下载网页，至此，网络通信结束<br>解析HTML构建DOM Tree<br>拿到服务器返回的网页后，首先，根据顶部定义的DTD类型进行对应的解析方式，网页的解析将会被交给内部的GUI渲染线程处理<br>渲染线程中的HTML解释器，将HTML网页和资源从字节流解释转换成字符流，再通过词法分析器将字符流解释成词，之后经过语法分析器根据词构建成节点，最后通过这些节点组建一个DOM树<br>这个过程中，如果遇到的节点是 JS 代码，就会调用 JS引擎 对 JS代码进行解释执行，此时由于 JS引擎 和 GUI渲染线程 的互斥，GUI渲染线程 就会被挂起，渲染过程停止，如果 JS 代码的运行中对DOM树进行了修改，那么DOM的构建需要从新开始<br>如果节点需要依赖其他资源，图片/CSS等等，就会调用网络模块的资源加载器来加载它们，它们是异步的，不会阻塞当前DOM树的构建<br>如果遇到的是 JS 资源URL（没有标记异步），则需要停止当前DOM的构建，直到 JS 的资源加载并被 JS引擎 执行后才继续构建DOM<br>解析CSS构建CSSOM Tree<br>CSS解释器会将CSS文件解释成内部表示结构，生成CSS规则树，这个过程也是和DOM解析类似的，CSS 字节转换成字符，接着词法解析与法解析，最后构成 CSS对象模型(CSSOM) 的树结构<br>构建的过程中浏览器得递归 DOM 树来确定元素到底是什么样式，为了 CSSOM 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 DOM 已经构建完了，也得等 CSSOM，然后才能进入下一个阶段<br>构建渲染树 (Render Tree)<br>接着 CSSOM 树和 DOM 树 合并成渲染树，也叫呈现树，渲染树 只包含渲染网页所需的节点，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上<br>布局 (Layout)<br>渲染树 同时包含了屏幕上的所有可见内容及其样式信息，有了渲染树，再接着就会进入布局 ( layout ) 阶段了，到目前为止，浏览器计算了哪些节点应该是可见的以及它们的计算样式，但还没有计算它们在设备视口内的确切位置和大小，这就是 布局 ( Layout ) 阶段，也称为 自动重排 或 回流 ( Reflow )<br>此阶段一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树<br>绘制 (Painting)<br>经由前几步我们知道了哪些节点可见、它们的计算样式以及几何信息，将这些信息及渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 绘制 或 栅格化 阶段<br>合成(Composite)<br>最后一步合成( composite )，这一步骤浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上<br>至此上述的内容就是我理解的一个URL从解析到渲染的生命历程了<br>干净简洁的概括式回答<br>PS：这里大体的点我觉得还是要答出来的，可以根据自己的了解进行某些方面的扩展，至少我觉得是这样子的，也是个人理解，欢迎探讨<br>面试管你好，URL输入到页面渲染，这是一个经典的话题，涉及的知识点也很多，我按照我的个人理解给您简单概括下，有不对的地方还请您指出<br>首先，客户端浏览器输入URL，由于是域名，应用层DNS开始解析域名<br>接着，应用层客户端发送一个HTTP请求，把拿到的应用层HTTP请求报文数据分割编号，为了方便安全的传输，传输层会通过TCP三次握手建立TCP/IP链接<br>建立连接后 网络层 IP协议会查询服务器 MAC地址 也就是物理地址进行数据包的传输<br>找到对方的 MAC地址 后，将数据发送到 数据链路层传输，到此客户端发送请求阶段结束<br>接收端的服务器在 数据链路层 接收到数据包，再通过相反的方式将数据一层一层的还原回 应用层<br>服务器接收到客户端发送的HTTP请求后，会查找客户端请求的资源，并返回响应报文<br>请求成功后，服务器会返回相应的网页，浏览器接收到响应成功的报文后便开始下载网页，至此，网络通信结束<br>浏览器拿到网页文件后，首先根据顶部定义的DTD类型进行对应解析方式，网页解析会交给内部GUI渲染线程处理<br>接着构建DOM树和CSSOM树，过程中，如果遇到节点是 JS ，就会调用 JS引擎 对 JS代码进行解释执行，此时由于 JS引擎 和 GUI渲染线程 互斥，GUI渲染线程 会被挂起，渲染过程停止，如果 JS 代码的运行中对DOM树进行了修改，那么DOM构建要从新开始，然后DOM树和CSSOM树构建为渲染树<br>然后进入布局阶段，计算渲染树节点在设备视口内的确切位置和大小<br>再接着将渲染树中每个节点转换成屏幕上的实际像素，也就是绘制阶段<br>最后的合成阶段浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上<br>问：TCP/IP四、五层，OSI七层模型有什么区别？<br>网络层次可划分为 四层因特网协议栈 和 七层因特网协议栈 ，起初网络分层是标准的七层，也就是我们所说的 OSI 七层模型 ，参考模型是国际标准化组织 ISO 制定的一个用于计算机或通信系统间互联的标准体系，一般称为 OSI参考模型 或 七层模型<br>所谓的 TCP/IP 四层模型 和 TCP/IP 五层模型 是以 OSI 七层 优化而来，把某些层进行合并了，本质上还是相同的，OSI七层模型 太过细化，有一定的参考意义，但实现起来比较繁琐，相比较而言，TCP/IP模型 比较简洁，具有较强的实际应用价值<br>TCP/IP 将计算机网络分成了四个层次，一般资料或教程里都是结合 OSI7层模型 和 TCP/IP4层模型，将计算机网络按照5层的模型来讲，5层模型只是为了方便介绍计算机网络原理而设计的，而在实际应用中还是 TCP/IP四层模型<br>各层对应关系如下</p>
<p>问：DNS解析可优化吗，为什么优化又怎样优化？<br>是否<br>可以优化<br>为什么<br>用户打开网站的整个流程中，DNS解析是第一环，当用户输入域名并敲回车后，系统调用 DNS客户端，寻找到用户配置或者自动分配的DNS IP，之后就开始整个解析过程，DNS服务器 完成解析到此域名的 数字IP服务器，一般情况下返回给定域名对应的IP地址会花费 20<del>120毫秒 的时间，而且在这个过程中浏览器什么都不会做直到DNS查询完毕<br>一旦解析完成，连接建立并保持，也就是顺利的访问以后，网页以后的下载速度就和DNS没关系了，直到下一次重新解析和发起访问请求<br>很多小型网站，DNS解析时间都接近 0.5s，有些甚至需要 1s 左右才可以解析出结果，一般网站用户的等待时间超过 8s 就会放弃访问，而对于电子商务网站，4s 就是用户忍耐极限，而一般经过优化的小型网站，DNS解析时间都可以控制在 200ms 左右，而带宽在 100M 左右的网站，经过优化，DNS解析时间可以控制在 50</del>100ms ，所以DNS优化还是很有必要的<br>怎样<br>DNS解析优化-善用缓存之TTL<br>DNS存在着多级缓存，每次找这么多级，很定耗时间，我们要尽量多的让用户直接从运营商的DNS缓存中拿到解析记录，这样就不需要走根域名服务器以下的这些过程，自然就节省了一些时间<br>购买域名做域名解析时，有一个 TTL 值，它指的是域名解析的生命周期 ( 秒为单位 )，简单来说它表示DNS服务器解析域名时记录在DNS服务器上的缓存时间，这个值的大小设置也是很有学问的，我们要在尽可能快的情况下又要保证当服务器出问题时能够尽快切换</p>
<p>我们自己肯定清楚自己的服务器有没有多台或备份，若无备份，那服务器宕机时只能生抗，所以，TTL 时间对于你来说是越长越好，因为 TTL 短的目的是服务器发生问题时，可以及时切换，这个对于没有备份的网站基本利用不上，所以这时你的 TTL 设置就越长越好，当然了，也不能太长，一般设置 TTL 3600 即可<br>若有备份或多台服务器，会发生由于服务器宕机需要及时做切换，TTL 时间越短切换越及时，但是 TTL 时间越短，也就意味着运营商DNS经常缓存不住，一般用户，设置为 TTL 600 即可，如果对及时切换，要求特别苛刻的网站，设置 TTL 120 就行</p>
<p>DNS解析优化-负载均衡<br>在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的，可以根据每台机器的负载量或该机器离用户地理位置的距离入手<br>就像我们使用CDN厂商做域名解析，它也是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容，CDN厂商的域名解析服务器用户量多被访问的次数也多，域名解析服务器的A记录基本上会被各地运营商的DNS一直缓存着，所以服务效果也是最好的<br>问：TCP/IP协议与UDP协议优缺点及区别？<br>首先请注意，这题目本身就是一个坑<br>TCP/IP协议 是一个协议簇，它包括很多协议，UDP协议 只是其中的一个，之所以命名为 TCP/IP协议，是因为TCP和IP协议是两个很重要的协议，就用它两命名了，仅此而已，SO，这个题目是不正确的，正确的问法应该是TCP协议和UDP协议优缺点及区别<br>你可能会说有面试官这样问吗？别说这抠字眼的题，还真有人因为忽略了这点被安排过 😄<br>问：TCP协议和UDP协议优缺点及区别？<br>优缺点<br>TCP 的优点： 稳定可靠， 这体现在TCP传递数据之前，会有三次握手来建立连接，且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约一些系统资源<br>TCP的缺点：占用系统资源高，慢且效率低，TCP在传递数据之前，要先建连接，会消耗时间，在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，每个连接都会占用系统的CPU、内存等硬件资源<br>UDP 的优点： 快，UDP是一个无状态的传输协议，所以它在传递数据时非常快<br>UDP 的缺点： 不可靠，不稳定，因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包<br>一般当我们对网络通讯质量有要求的时候，就应该使用TCP，要把整个数据准确无误的传递给对方，比如HTTP、HTTPS、FTP等协议，当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP，如语音，视频等<br>区别</p>
<p>TCP协议基于连接UDP协议无连接</p>
<p>TCP协议面向字节流，简单说TCP把数据看成一连串无结构的字节流而UDP协议面向报文</p>
<p>TCP协议传送数据，无差错不丢失不重复，且按序到达，UDP不保证可靠交付和顺序，可能丢包</p>
<p>TCP首部开销20字节，UDP的首部开销较小，只有8个字节</p>
<p>TCP协议连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>问：简单介绍下TCP三次握手四次挥手？<br>三次握手 ( 网图侵删 )</p>
<p>PS: 请认真看图并配合下面文字理解<br>开始时，双端处于 CLOSE (关闭状态)，服务端要提供服务，会主动监听某个端口，进入 LISTEN (监听状态)<br>客户端主动发送连接的SYN包，之后进入 SYN-SENT (同步已发送状态)<br>服务端在收到客户端发来的SYN包后，回复SYN/ACK包，之后进入 SYN-RCVD (同步收到状态)<br>客户端收到服务端发来的SYN/ACK包后，确认对方后回复ACK包，并进入 ESTABLISHED (已建立连接状态)<br>当服务器收到客户端的确认后也进入 ESTABLISHED (已建立连接状态) ，此后双方就可以开始通信了<br>四次挥手 ( 网图侵删 )</p>
<p>PS: 请认真看图并配合下面文字理解<br>开始时双端还都处于 ESTABLISHED (已建立连接状态) 并传输数据，某一端可以主动发起 FIN 包准备断开连接，上图为客户端发起 FIN 请求，在发出FIN后，客户端进入 FIN-WAIT-1 (终止等待状态1)<br>服务端收到 FIN 消息后，回复 ACK 表示知道了，并从ESTABLISHED (已建立连接状态)进入 CLOSED-WAIT (关闭等待状态)，开始做一些断开连接前的准备工作<br>客户端收到之前FIN的回复 ACK 消息后，进入 FIN-WAIT-2 (终止等待状态2)，当服务端做好断开前的准备工作后，也会发送一个 FIN/ACK 的消息給客户端，表示我也好了，请求断开连接，并在发送消息后，服务端进入 LAST-ACK (最后确认状态)<br>客户端在收到 FIN/ACK 消息后，会立即回复 ACK ，表示知道了，并进入 TIME_WAIT ( 时间等待状态)，为了稳定和安全考虑，客户端会在 TIME-WAIT ( 时间等待状态) 等待 2MSL ( 最长报文段寿命 ) 的时长，最终进入 CLOSED ( 关闭状态 )<br>服务端收到客户端回复的 ACK 消息后，直接从 LAST-ACK (最后确认状态) 状态进入 CLOSED ( 关闭状态 )<br>四次挥手之后，双端都进入 CLOSED ( 关闭状态 )，在此之后，双端正式断开了连接<br>PS:  MSL ( Maximum Segment Lifetime ) 为 最长报文段寿命，它指的是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，TCP允许不同的实现可以设置不同的 MSL 值<br>问：为什么建立连接是三次握手，关闭连接确是四次挥手？<br>建立连接的时候， 服务器在  LISTEN (监听状态) ，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端就可以了<br>而关闭连接时，服务器收到对方的 FIN 报文时，仅代表对方不再发送数据了但是还能接收数据，而自己未必全部数据都发送给对方了，所以自己可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次<br>问：为什么要三次握手创建链接，最后一次确认有必要吗？<br>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误<br>如果使用两次握手建立连接，假如客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，然后客户端和服务器经过两次握手完成连接，传输数据后关闭连接，此时之前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手机制就会让客户端和服务器再次建立连接，会导致不必要的错误和资源的浪费<br>采用三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认，由于服务器收不到确认，就会知道客户端并没有请求连接<br>为什么不用四次握手就更简单了，三次就可以创建安全无误的连接为什么用四次，那不是浪费资源嘛<br>问：三次握手过程中可以携带数据吗？<br>第一次、第二次握手不可以携带数据，因为一握二握时还没有建立连接，会让服务器容易受到攻击<br>而第三次握手，此时客户端已经处于 ESTABLISHED (已建立连接状态) ，对于客户端来说，已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也是没问题的<br>问：四次挥手为什么客户端最后还要等待2MSL？<br>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器<br>第二，比如上面提到了的 已经失效的连接请求报文段 出现在连接中这种状况，客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样新连接中就不会出现旧连接的请求报文<br>问：如果已经建立了连接，但客户端突然故障怎么办？<br>TCP 还设有一个保活计时器，客户端如果出现故障，服务器总不能一直等下去，白白浪费资源啊，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时<br>若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，然后每隔75秒就会再发送一次，10次探测报文后仍然没反应的话，服务器就认为客户端出了故障，接着就关闭连接<br>问：HTTP 的请求方法？<br>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法<br>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</p>
<p>序号<br>方法<br>描述</p>
<p>1<br>GET<br>请求指定的页面信息，并返回实体主体</p>
<p>2<br>HEAD<br>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</p>
<p>3<br>POST<br>向指定资源提交数据进行处理请求 ( 例如提交表单或者上传文件 )，数据被包含在请求体中，POST 请求可能会导致新的资源的建立和/或已有资源的修改</p>
<p>4<br>PUT<br>从客户端向服务器传送的数据取代指定的文档的内容</p>
<p>5<br>DELETE<br>请求服务器删除指定的页面</p>
<p>6<br>CONNECT<br>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</p>
<p>7<br>OPTIONS<br>允许客户端查看服务器的性能</p>
<p>8<br>TRACE<br>回显服务器收到的请求，主要用于测试或诊断</p>
<p>9<br>PATCH<br>是对 PUT 方法的补充，用来对已知资源进行局部更新</p>
<p>问：HTTP 状态码分别代表什么？<br>状态码有五类分别代表</p>
<p>1xx: 协议处理中状态，还需后续操作<br>2xx: 成功状态<br>3xx: 重定向状态，资源位置发生变动，需要重新请求<br>4xx: 请求报文有误<br>5xx: 服务器端错误</p>
<p>详细状态码就不啰嗦了，直接 copy 菜鸟教程了一份，看一看吧，心中有个印象</p>
<p>状态码<br>英文名称<br>描述</p>
<p>100<br>Continue<br>继续。客户端应继续其请求</p>
<p>101<br>Switching Protocols<br>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</p>
<p>200<br>OK<br>请求成功。一般用于GET与POST请求</p>
<p>201<br>Created<br>已创建。成功请求并创建了新的资源</p>
<p>202<br>Accepted<br>已接受。已经接受请求，但未处理完成</p>
<p>203<br>Non-Authoritative Information<br>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</p>
<p>204<br>No Content<br>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p>
<p>205<br>Reset Content<br>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</p>
<p>206<br>Partial Content<br>部分内容。服务器成功处理了部分GET请求</p>
<p>300<br>Multiple Choices<br>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p>
<p>301<br>Moved Permanently<br>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p>
<p>302<br>Found<br>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p>
<p>303<br>See Other<br>查看其它地址。与301类似。使用GET和POST请求查看</p>
<p>304<br>Not Modified<br>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p>
<p>305<br>Use Proxy<br>使用代理。所请求的资源必须通过代理访问</p>
<p>306<br>Unused<br>已经被废弃的HTTP状态码</p>
<p>307<br>Temporary Redirect<br>临时重定向。与302类似。使用GET请求重定向</p>
<p>400<br>Bad Request<br>客户端请求的语法错误，服务器无法理解</p>
<p>401<br>Unauthorized<br>请求要求用户的身份认证</p>
<p>402<br>Payment Required<br>保留，将来使用</p>
<p>403<br>Forbidden<br>服务器理解请求客户端的请求，但是拒绝执行此请求</p>
<p>404<br>Not Found<br>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p>
<p>405<br>Method Not Allowed<br>客户端请求中的方法被禁止</p>
<p>406<br>Not Acceptable<br>服务器无法根据客户端请求的内容特性完成请求</p>
<p>407<br>Proxy Authentication Required<br>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</p>
<p>408<br>Request Time-out<br>服务器等待客户端发送的请求时间过长，超时</p>
<p>409<br>Conflict<br>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</p>
<p>410<br>Gone<br>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</p>
<p>411<br>Length Required<br>服务器无法处理客户端发送的不带Content-Length的请求信息</p>
<p>412<br>Precondition Failed<br>客户端请求信息的先决条件错误</p>
<p>413<br>Request Entity Too Large<br>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</p>
<p>414<br>Request-URI Too Large<br>请求的URI过长（URI通常为网址），服务器无法处理</p>
<p>415<br>Unsupported Media Type<br>服务器无法处理请求附带的媒体格式</p>
<p>416<br>Requested range not satisfiable<br>客户端请求的范围无效</p>
<p>417<br>Expectation Failed<br>服务器无法满足Expect的请求头信息</p>
<p>500<br>Internal Server Error<br>服务器内部错误，无法完成请求</p>
<p>501<br>Not Implemented<br>服务器不支持请求的功能，无法完成请求</p>
<p>502<br>Bad Gateway<br>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</p>
<p>503<br>Service Unavailable<br>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</p>
<p>504<br>Gateway Time-out<br>充当网关或代理的服务器，未及时从远端服务器获取请求</p>
<p>505<br>HTTP Version not supported<br>服务器不支持请求的HTTP协议的版本，无法完成处理</p>
<p>问：HTTP与HTTPS的区别？<br>HTTP协议传输的数据都是未加密的，也就是明文的，所以使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer） 协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS<br>简单来说，HTTPS协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，更多HTTP和HTTPS内容请自行百度，这里就不长篇大论了<br>那么简单总结下有区别</p>
<p>HTTPS协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用</p>
<p>HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议</p>
<p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</p>
<p>HTTP的连接很简单，是无状态的，HTTPS协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全</p>
<p>问：什么是简单请求和非简单请求？<br>CORS（cross-origin resource sharing），跨源资源共享，就是广大前端同学所说的跨域，想必大家都了解，不了解这也不做介绍了，不了解可以看 HTTP访问控制（CORS）- MDN传送门  😄<br>CORS中把请求定义为了两类</p>
<p>简单请求<br>非简单请求</p>
<p>那么什么是简单请求什么是非简单请求呢？其实也很简单，我们只需要知道什么是简单请求，其余的就都是非简单的了，而简单请求需要满足的条件是</p>
<p>请求方式只能是GET、POST、HEAD三种<br>HTTP头部信息不超过一下几种字段</p>
<p>无自定义头部字段<br>Accept、Accept-Language、Content-Language、Last-Event-ID<br>Content-Type只有三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</p>
<p>简单请求需要满足上面的条件，其实平常也就是传统的表单请求了，看了上面的简单请求条件，那么非简单请求是不是就呼之欲出了呢，比如下面这些只要满足一个就是非简单请求</p>
<p>请求方式是PUT、DELETE</p>
<p>自定义头部字段</p>
<p>发送JSON格式数据等等</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，请求方式为 OPTIONS，称为 预检请求 (preflight)<br>浏览器会先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段，得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就会报错，这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，防止服务器收到大量 DELETE 和 PUT请求，这些传统的表单不可能跨域发出的请求<br>问：CSS 资源加载会阻塞渲染怎样优化？<br>优化DOM树，DOM尽可能的小<br>CSS尽量用 id 和 class 少直接用标签，因为标签节点样式是可以继承的，所以在构建的过程中浏览器得递归 DOM 树来确定元素到底是什么样式<br>对于首屏渲染需要用到的CSS代码加入Inline CSS ( 内联样式 )<br>对于首屏渲染不需要用到的CSS，可以使用文件形式并在页面内容渲染完成后再加载<br>问：什么是回流和重绘以及区别？<br>要知道，生成DOM树时是包括 display:none 的节点的，DOM树和CSSOM树的基础上根据节点的集合属性 margin/padding/width/height等 生成渲染树 ( render ) ，渲染树不包括 display:none 的节点和 head 等节点，但是包括 visibility:hidden 的节点<br>当渲染树节点因为大小边距等问题发生改变而需要重建的过程，叫做 回流 (Reflow)<br>元素发生的改变只是影响了元素的一些外观之类的时候 ( 例如，背景色，边框颜色，文字颜色等 )，此时只需要应用新样式绘制这个元素就可以了，称之为 重绘 (Repaint)<br>回流必将引起重绘，而重绘不一定会引起回流，很明显 回流 代价较大<br>问：什么会引起回流？</p>
<p>页面渲染初始化</p>
<p>DOM结构改变，比如删除了某个节点</p>
<p>render树变化，比如减少了 padding ( 内边距 )</p>
<p>窗口 resize 事件触发时</p>
<p>某些 JS 属性，引发回流，很多浏览器会对回流做优化，等到数量足够时做一次批处理回流， 但除了 render树 的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效</p>
<p>offset ( Top/Left/Width/Height )<br>scroll ( Top/Left/Width/Height )<br>cilent ( Top/Left/Width/Height )<br>width, height<br>调用了 getComputedStyle() 或者IE的 currentStyle</p>
<p>问：如何减少和避免回流重绘？<br>减少逐项更改样式，最好一次性更改 style，或者将样式定义为 class 并一次性更新<br>避免循环操作DOM，让DOM离线后再修改</p>
<p>创建一个 documentFragment ，在它上面应用所有DOM操作，最后再把它添加到 window.document<br>先把DOM节点 display:none ( 会触发一次 reflow)，然后做修改后，再把它显示出来<br>克隆一个DOM节点在内存里，修改之后，与在线的节点相替换</p>
<p>避免多次读取offset等属性，无法避免则将它们缓存到变量<br>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高<br>改变字体大小也会引发回流，所以尽可能减少这种操作<br>table布局，一个小改动会造成整个table的重新布局，所以，少用为好<br>问：你了解普通图层和复合图层吗？<br>浏览器渲染的图层一般包含两大类：普通图层 以及 复合图层<br>普通文档流可以理解为一个复合图层，我们叫它默认复合层，因为里面不管添加多少元素，其实都是在同一个复合图层中，absolute 布局、 fixed 也一样，虽然可以脱离普通文档流，但它仍然属于 默认复合层<br>复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，从而提升性能，但也不能大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡，因小失大<br>GPU中，各个复合图层是单独绘制的，所以也互不影响，通过 硬件加速 的方式，会声明一个 新的复合图层 ，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响 默认复合层 里的回流重绘<br>PS： 硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页<br>问：浏览器页面渲染优化？</p>
<p>HTML文档结构层次尽量少，最好不深于六层</p>
<p>JS 脚本尽量后放</p>
<p>样式结构层次尽量简单</p>
<p>少量首屏样式使用内联方式放在标签内</p>
<p>在脚本中尽量减少DOM操作，尽量访问离线DOM样式信息，避免过度触发回流</p>
<p>减少通过 JS 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画</p>
<p>尽量减少浏览器重排和重绘的一些情况发生</p>
<p>2020年了！就不要使用 table 布局了</p>
<p>CSS 动画中尽量只使用 transform 和 opacity ，不会发生重排和重绘</p>
<p>隐藏在屏幕外，或在页面滚动时，尽量停止动画</p>
<p>尽可能只使用 CSS 做动画，CSS动画肯定比 JS 动画要好很多</p>
<p>避免浏览器的隐式合成</p>
<p>改变复合层的尺寸</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93/" data-id="cmd8fcqf1003664g5evnfgbym" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-程序员/面试/收集的面试题 - HTTP 篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTTP%20%E7%AF%87/" class="article-date">
  <time datetime="2025-07-18T06:03:17.131Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTTP%20%E7%AF%87/">收集的面试题 - HTTP 篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTTP%20%E7%AF%87/" data-id="cmd8fcqez002t64g5fjo393zn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-程序员/面试/收集的前端面试题 - 工程化篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87/" class="article-date">
  <time datetime="2025-07-18T06:03:17.131Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87/">收集的前端面试题 - 工程化篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87/" data-id="cmd8fcqf0002y64g585mv5dlm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-程序员/面试/收集的面试题 - 算法和数据结构篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/" class="article-date">
  <time datetime="2025-07-18T06:03:17.131Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/">收集的面试题 - HTTP 篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/" data-id="cmd8fcqf0003164g56fft21bn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-程序员/面试/收集的前端面试题 - Vue2 篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue2%20%E7%AF%87/" class="article-date">
  <time datetime="2025-07-18T06:03:17.130Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue2%20%E7%AF%87/">收集的前端面试题 - Vue3 篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue2%20%E7%AF%87/" data-id="cmd8fcqez002p64g5hkmo5yp7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-程序员/面试/收集的前端面试题 - Vue3 篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue3%20%E7%AF%87/" class="article-date">
  <time datetime="2025-07-18T06:03:17.130Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue3%20%E7%AF%87/">收集的前端面试题 - Vue3 篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h2 id="谈谈对-MVVM-的理解"><a href="#谈谈对-MVVM-的理解" class="headerlink" title="谈谈对 MVVM 的理解"></a>谈谈对 MVVM 的理解</h2><p>MVVM 是 Model-View-ViewModel 的锁鞋，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 代表数据模型，View 代表 UI 组件，ViewModel 是 VIew 和 Model 的桥梁，数据会绑定到 ViewModel 上，并自动将数据渲染到页面中，视图变化的时候会通知 ViewModel 更新数据。</p>
<h2 id="Vue3-对比-Vue2-有哪些优势"><a href="#Vue3-对比-Vue2-有哪些优势" class="headerlink" title="Vue3 对比 Vue2 有哪些优势"></a>Vue3 对比 Vue2 有哪些优势</h2><p>性能更好，打包体积更小，更好的 ts 支持，更好的代码组织，更好的逻辑抽离，更多的新功能</p>
<h2 id="Vue3-的新特性"><a href="#Vue3-的新特性" class="headerlink" title="Vue3 的新特性"></a>Vue3 的新特性</h2><ul>
<li>性能提升<ul>
<li>响应式性能提升，由原来的 <code>Object.defineProperty</code> 改为 <code>ES6</code> 的 Proxy，速度更快</li>
<li>重写了 <code>Vdom</code>，diff 算法优化，增加了静态标记</li>
<li>进行了模板编译优化，静态提升，不参与更新的元素只被创建一次</li>
<li>更高效的组件初始化</li>
</ul>
</li>
<li>更好的支持 TypeScript<ul>
<li>Vue2 选用 Flow 做类型检查来避免一些因类型问题导致的错误，但是 Flow 对于一些复杂场景类型的检查，支持得并不好</li>
<li>Vue3 抛弃了 Flow，使用 TypeScript 重构了整个项目</li>
<li>TypeScript 提供了更好的类型检查，能支持复杂的类型推断</li>
</ul>
</li>
<li>新增 Composition API<ul>
<li>提高代码逻辑的复用性和维护性，同时代码压缩性更强</li>
<li>定义 methods、watch、computed、data 都放在了 setup() 函数中</li>
<li>setup() 函数会在 created() 之前执行，beforeCreate &gt; setup &gt; cteated</li>
</ul>
</li>
<li>新增组件<ul>
<li>Fragment 不再限制 template 只有一个根节点</li>
<li>Teleport 传送门，允许我们将控制的内容传送到任意 DOM中，就是指定组件挂载位置，如通过 #id</li>
<li>Suspense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验</li>
</ul>
</li>
<li>Tree-shaking，支持摇树优化<br>会将不需要的模块修剪掉，打包真正需要的模块，优化后的项目体积只有原来的一般，加载速度会更快。</li>
<li>Custom Renderer API，自定义渲染器<br>实现 DOM 的方式进行 WebGL 编程</li>
</ul>
<h2 id="Vue3-和-Vue2-的区别"><a href="#Vue3-和-Vue2-的区别" class="headerlink" title="Vue3 和 Vue2 的区别"></a>Vue3 和 Vue2 的区别</h2><ul>
<li>源码组织方式变化，使用 TypeScript 重写</li>
<li>支持 Compsition API，基于函数的 API，更加灵活地组织组件逻辑（Vue2 是 Options API）</li>
<li>响应式系统提升，从 defineProperty 到 Proxy，可监听动态新增删除属性以及数组的变化</li>
<li>编译优化，Vue2 通过标记静态根节点优化 diff，Vue3 标记和提升所有静态根节点，diff 的时候只需要对比动态节点内容</li>
<li>打包体积优化，移除了不常用的 API（inline-template、filter）</li>
<li>生命周期的变化，使用 setup 代替了之前的 beforeCreate 和 created</li>
<li>Vue3 的 template 模板支持多个根标签</li>
<li>更多</li>
</ul>
<h2 id="Vue3-性能提升主要是通过哪些方面体现的"><a href="#Vue3-性能提升主要是通过哪些方面体现的" class="headerlink" title="Vue3 性能提升主要是通过哪些方面体现的"></a>Vue3 性能提升主要是通过哪些方面体现的</h2><ul>
<li><strong>编译阶段优化</strong><br>回顾 Vue2，我们知道每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据 property 记录为依赖，当依赖发生变化，触发 setter，则会通知 watcher，从而使关联的组件重新渲染，因此，Vue3 在编译阶段做了进一步的优化：<ul>
<li><strong>diff 算法优化</strong><br>增加了静态标记，其作用是为了在发生变化的地方添加一个 flag 标记，下次发生变化时直接在该处进行比较。</li>
<li><strong>静态提升</strong><br>Vue3 对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接服用。避免了重复的创建操作，优化内存。</li>
<li><strong>事件监听缓存</strong><br>默认情况下绑定事件行为会被视为动态绑定（未开启事件监听器缓存），所以每次都会追踪它的变化，开启事件侦听器缓存后，没有了静态标记，下次 diff 算法的时候直接使用。</li>
<li><strong>SSR 优化</strong><br>当静态内容大到一定量级的时候，会用 createStaticVNode 方法在客户端生成一个 static node，这些静态 node会被直接 innerHTML，就不需要创建对象，然后根据对象渲染</li>
</ul>
</li>
<li><strong>源码体积</strong><br>相比 Vue2，Vue3 整体体积变小了，移除了一些不常用的 API，最重要的是增加了 Treeshaking，任何一个函数，如 ref、reactive、computed 等，仅仅在用到的时候才打包，没用到的模块会被移除，减小体积。</li>
<li><strong>响应式系统</strong><br>Vue2 采用 defineProperty 来实现数据劫持，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter 实现响应式。<br>Vue3 采用 Proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听，不需要深度遍历，另外还解决了 2 中的不足：<ul>
<li>可以监听动态属性的添加</li>
<li>可以监听数组的索引和数组的 length 属性</li>
<li>可以监听删除属性</li>
</ul>
</li>
</ul>
<h2 id="Vue3-的响应式原理"><a href="#Vue3-的响应式原理" class="headerlink" title="Vue3 的响应式原理"></a>Vue3 的响应式原理</h2><h3 id="Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢"><a href="#Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢" class="headerlink" title="Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢?"></a>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢?</h3><p>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。</p>
<h3 id="监测数组的时候可能触发多次get-set，那么如何防止触发多次呢？"><a href="#监测数组的时候可能触发多次get-set，那么如何防止触发多次呢？" class="headerlink" title="监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？"></a>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</h3><p>我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p>
<h2 id="v-model-双向绑定的原理是什么"><a href="#v-model-双向绑定的原理是什么" class="headerlink" title="v-model 双向绑定的原理是什么"></a>v-model 双向绑定的原理是什么</h2><p>v-model 本质上是一个语法糖，可以看成是 value + input 方法的组合。可以通过 model 属性的 prop 和 event 属性来进行自定义。原生的 v-model 会根据标签的不同生成不同的事件和属性。</p>
<h2 id="Options-API-的生命周期"><a href="#Options-API-的生命周期" class="headerlink" title="Options API 的生命周期"></a>Options API 的生命周期</h2><ul>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>onMounted</li>
<li>beforeUpdate</li>
<li>onUpdated</li>
<li>beforeUnmount</li>
<li>onUnmounted</li>
<li>onActivated</li>
<li>onDeactivated</li>
<li>onErrorCaptured</li>
</ul>
<h2 id="Composition-API-和-Options-API"><a href="#Composition-API-和-Options-API" class="headerlink" title="Composition API 和 Options API"></a>Composition API 和 Options API</h2><p>Options API 是一种基于对象的 API，用组件的选项（data、computed、methods、watch）组织逻辑在大多数情况下是可行的，然后当组件变得复杂，导致对应属性的列表也会增加，可能会导致组件难以理解和阅读。</p>
<p>Composition API 是一种函数式的 API，组件根据逻辑功能来组织，一个功能定义的所有 API 会放在一起（更加的 高内聚、低耦合）</p>
<p>Composition API 相对于 Options API 有以下优点：</p>
<ul>
<li>逻辑组织<ul>
<li>Options API 在处理大型组件时，内部逻辑点容易碎片化，可能同时存在于各选项中（data、computed、methods、watch），我们必须不断地“跳转”相关代码的选项块，这种碎片化使得理解和维护复杂组件变得困难。</li>
<li>Composition API 把某个逻辑相关代码全部放在一个函数里。</li>
</ul>
</li>
<li>逻辑复用<br>在 Vue2 中，使用混入函数 mixin 会存在两个非常明显的问题，命名冲突和数据来源不清晰，而 Composition API 可以通过编写多个 hooks 函数来实现逻辑复用。</li>
</ul>
<h2 id="reactive、ref-、toRef-和-toRefs"><a href="#reactive、ref-、toRef-和-toRefs" class="headerlink" title="reactive、ref 、toRef 和 toRefs"></a>reactive、ref 、toRef 和 toRefs</h2><ul>
<li>ref，函数可以接受基本数据类型和引用数据类型，创建的响应式数据在模板中可以直接使用，在 JavaScript 中使用需要通过 .value 的形式。</li>
<li>reactive，函数只能接受引用数据类型。</li>
<li>toRef，函数可以把响应式对象中的某个属性转换成 ref 对象。</li>
<li>toRefs，将一个响应式对象转为普通对象，对象的每一个属性都转换成 ref 对象。</li>
</ul>
<h2 id="script-setup"><a href="#script-setup" class="headerlink" title="script setup"></a>script setup</h2><p>Vue3 的语法糖，简化了组合式 API 的写法</p>
<ul>
<li>属性和方法无需返回，可直接使用</li>
<li>引入的组件会自动注册，无需通过 components 手动注册</li>
<li>使用 defineProps 接收父组件传递的值</li>
<li>useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件</li>
<li>默认不会对外暴露任何属性，如果有需要可使用 definExpose</li>
</ul>
<h3 id="在-setup-中如何获取组件实例"><a href="#在-setup-中如何获取组件实例" class="headerlink" title="在 setup 中如何获取组件实例"></a>在 setup 中如何获取组件实例</h3><p>使用 getCurrentInstance() 方法来获取组件实例，该方法返回一个对象，对象包含了组件实例及其相关信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="title function_">getCurrentInstance</span>()</span><br></pre></td></tr></table></figure>

<h2 id="v-if-和-v-for-的优先级"><a href="#v-if-和-v-for-的优先级" class="headerlink" title="v-if 和 v-for 的优先级"></a>v-if 和 v-for 的优先级</h2><p>在 Vue2 中 v-for 优先级更高，但在 Vue3 中 v-if 优先级更高。</p>
<h2 id="watch-和-watchEffect"><a href="#watch-和-watchEffect" class="headerlink" title="watch 和 watchEffect"></a>watch 和 watchEffect</h2><p>watch 和 watchEffect 都是监听器，watchEffect 是一个副作用函数，它们之间的区别：</p>
<ul>
<li>watch 需要指定监视的数据源和回调函数，watchEffect，不需要指定监视的数据源，它会自动追踪响应式数据的变化，回调函数中用到了哪个数据，就监视哪个数据</li>
<li>watch 可以访问到旧值和新值，watchEffect 只能访问到新值</li>
<li>watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 会立即执行一次，这一点通过 watch 的配置项 immediate 可以改变</li>
<li>watchEffect 有点像 computed<ul>
<li>但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值</li>
<li>而 watchEffect 注重的是过程（回调函数的执行），所以不用写返回值</li>
</ul>
</li>
<li>watch 与 Vue2 中的 watch 配置功能一致，但需要注意<ul>
<li>监视 reactive 定义的响应式数据时，oldValue 无法正确获取，且会强制开启深度检测（deep 配置失效）</li>
<li>监视 reactive 定义的响应式数据中某个属性时，deep 配置有效</li>
</ul>
</li>
</ul>
<h2 id="Vue2-Vue3-组件通信方式"><a href="#Vue2-Vue3-组件通信方式" class="headerlink" title="Vue2/Vue3 组件通信方式"></a>Vue2/Vue3 组件通信方式</h2><p>Vue3 通信方式</p>
<ul>
<li>props</li>
<li>$emit</li>
<li>expose/ref</li>
<li>$attrs</li>
<li>v-model</li>
<li>provide/inject</li>
<li>Vuex/pinia</li>
<li>mitt</li>
</ul>
<p>Vue2 通信方式</p>
<ul>
<li>props</li>
<li>$emit/v-on</li>
<li>.sync</li>
<li>v-model</li>
<li>ref</li>
<li>children/parent</li>
<li>attrs/listeners</li>
<li>provide/inject</li>
<li>eventBus</li>
<li>Vuex</li>
<li>$root</li>
<li>slot</li>
</ul>
<!-- # 收集的前端面试题 - Vue3 篇

## Vue3 有什么更新

- 响应式系统
  - Proxy 代替 Object.defineProperty
  - 基于 ES6 Map 代替 Object
  - 基于 ES6 Set 代替 Array
  - 基于 ES6 WeakMap 代替 Object
  - 基于 ES6 WeakSet 代替 Array -->



<ul>
<li>Vue 的生命周期有哪些，以及每个生命周期做了什么</li>
<li>Vue 的响应式原理是什么，Vue3 中是如何实现的</li>
<li>Vue3 和 Vue2 有什么区别</li>
<li>谈谈对 MVVM 的理解</li>
<li>在 Vue2 中如何检测数据的变化</li>
<li>v-model 双向绑定的原理是什么</li>
<li>Vue2 和 Vue3 渲染器的 diff 算法分别说一下</li>
<li>Vue2/3 组件通信方式</li>
<li>Vue 的路由实现，hash 和 history 路由实现原理</li>
<li>说一下 v-if 和 v-show 的区别</li>
<li>keep-alive 的常用属性和实现原理</li>
<li>nextTick 的作用是什么，实现原理是什么</li>
<li>说一下 Vue SSR 的实现原理</li>
<li>Vue 组件的 data 为什么必须是函数</li>
<li>说一下 Vue 的 computed 的实现原理</li>
<li>说一下 Vue complier 的实现原理</li>
<li>Vue 和 React 的区别</li>
<li>说一下 watch 与 computed 的区别是什么，以及对应的使用场景</li>
<li>Vue 有哪些修饰符</li>
<li>如何实现 Vue 项目的性能优化</li>
<li>Vue 中的 SPA 应用如何优化首屏加载速度</li>
<li>Vue 中的 key 的作用是什么</li>
<li>你的接口请求一般放在哪个生命周期中？为什么</li>
<li>Vue3 对比 Vue2 有什么优势</li>
<li>描述 Vue3 的生命周期</li>
<li>如何看待 Composition API 和 Options API</li>
<li>Vue3 有什么更新</li>
<li>Proxy 和 Object.defineProperty 的区别</li>
<li>Vue3 升级了哪些重要功能</li>
<li>Vue2 和 Vue3 核心 diff 算法区别</li>
<li>Vue3 为什么比 Vue2 快</li>
<li>Vue3 如何实现响应式</li>
<li>Vue3 编译做了哪些优化</li>
<li>watch 和 watchEffect 的区别</li>
<li>请介绍 Vue3 中的 Teleport（瞬移） 组件，是什么以及使用场景</li>
<li>如何理解 reactive、ref、toRef 和 toRefs</li>
<li>谈谈 pinia</li>
<li>EventBus 和 mitt 的区别</li>
<li>script setup 是什么</li>
<li>v-if 和 v-for 的优先级</li>
<li>setup 中如何获取组件实例</li>
<li>Vue3 中的 Suspense 是什么，如何是用它来处理异步组件</li>
<li>Vue3 性能提升主要是通过什么方面体现的</li>
<li>Vue3 为什么要用 Proxy API 替代 defineProperty API</li>
<li>Vue3 中的 Treeshaking 特性</li>
<li>说说你对 SPA 单页面的理解，它的优缺点分别是什么</li>
<li>v-show 与 v-if 有什么区别</li>
<li>Class 与 Style 如何动态绑定</li>
<li>怎么理解 Vue 的单向数据流</li>
<li>computed 和 watch 的区别和运用的场景</li>
<li>直接给一个数组项赋值，Vue 能检测到变化吗</li>
<li>谈谈你对 Vue 生命周期的理解</li>
<li>Vue 的父组件和子组件生命周期钩子函数执行顺序</li>
<li>在哪个生命周期内调用异步请求</li>
<li>在什么阶段才能访问操作DOM</li>
<li>父组件可以监听到子组件的生命周期吗</li>
<li>谈谈你对 keep-alive 的了解</li>
<li>组件中 data 为什么是一个函数</li>
<li>v-model 的原理</li>
<li>Vue 组件间通信有哪几种方式</li>
<li>你使用过 Vuex 吗</li>
<li>使用过 Vue SSR 吗？说说 SSR</li>
<li>vue-router 路由模式有几种</li>
<li>能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</li>
<li>什么是 MVVM</li>
<li>Vue 是如何实现数据双向绑定的</li>
<li>Vue 框架怎么实现对象和数组的监听</li>
<li>Proxy 与 Object.defineProperty 优劣对比</li>
<li>Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</li>
<li>虚拟 DOM 的优缺点</li>
<li>虚拟 DOM 实现原理</li>
<li>Vue 中的 key 有什么作用</li>
<li>你有对 Vue 项目进行哪些优化</li>
<li>对于即将到来的 vue3.0 特性你有什么了解的吗</li>
<li>说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20Vue3%20%E7%AF%87/" data-id="cmd8fcqez002r64g54ba972lk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-程序员/面试/收集的前端面试题 - TypeScript 篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20TypeScript%20%E7%AF%87/" class="article-date">
  <time datetime="2025-07-18T06:03:17.130Z" itemprop="datePublished">2025-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20TypeScript%20%E7%AF%87/">收集的前端面试题 - TypeScript 篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h2 id="什么是-TypeScript"><a href="#什么是-TypeScript" class="headerlink" title="什么是 TypeScript"></a>什么是 TypeScript</h2><p>TypeScript是一种由微软开发的开源编程语言，它是JavaScript的超集。TypeScript通过添加静态类型、类、接口和模块等功能，使得在大型应用程序中更容易进行维护和扩展。它可以被编译为纯JavaScript，从而能够在任何支持JavaScript的地方运行。使用TypeScript可以帮助开发人员在编码过程中避免一些常见的错误，并提供更好的代码编辑功能和工具支持。</p>
<h2 id="类型声明和类型推断的区别，并举例"><a href="#类型声明和类型推断的区别，并举例" class="headerlink" title="类型声明和类型推断的区别，并举例"></a>类型声明和类型推断的区别，并举例</h2><p>类型声明是显式地为变量或者函数指定类型，而类型推断是 TypeScript 根据赋值语句右侧的值自动推断变量类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="comment">// 类型推断</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>; <span class="comment">// 推断为 number 类型</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是接口（interface），作用和使用场景，接口和类型别名（Type-Alias）的区别"><a href="#什么是接口（interface），作用和使用场景，接口和类型别名（Type-Alias）的区别" class="headerlink" title="什么是接口（interface），作用和使用场景，接口和类型别名（Type Alias）的区别"></a>什么是接口（interface），作用和使用场景，接口和类型别名（Type Alias）的区别</h2><p><strong>interface</strong></p>
<ol>
<li>定义对象类型，主要用于定义对象的形状，描述对象应该具有哪些属性和方法<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可扩展性，interface 可以被扩展，可以通过继承来添加更多的属性和方法<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">gender</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现接口，以确保类具有接口中定义的所有属性和方法<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>type</strong></p>
<ol>
<li>定义类型别名，可以用于定义任何类型的别名，包括基本类型、联合类型、交叉类型等。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示一个可以是字符串或数字的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumber</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure></li>
<li>不能被扩展。</li>
<li>用于复杂类型，如函数类型、元组类型等。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示一个接受一个数字参数并返回 void 的函数</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Callback</span> = <span class="function">(<span class="params"><span class="attr">arg</span>: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>interface 用于描述对象的形状，描述对象应该具有的属性和方法。在 TypeScript 中，interface 可以用来约束对象的结构，以提高代码的可读性和维护性。</p>
<p>总结：</p>
<ul>
<li>interface 和 type 在很多情况下可以相互替代，但在一些特定场景下，选择其中一个可能更加合适</li>
<li>如果主要定义对象的形状，并且可能需要扩展，那么 interface 是一个好的选择</li>
<li>如果需要定义复杂的类型别名，或者不需要扩展的类型，那么 type 是一个好的选择</li>
</ul>
<h2 id="什么是泛型（generics），作用和使用场景"><a href="#什么是泛型（generics），作用和使用场景" class="headerlink" title="什么是泛型（generics），作用和使用场景"></a>什么是泛型（generics），作用和使用场景</h2><p>泛型是一种参数化类型，它可以在定义时不确定具体的类型，而是在使用时才确定具体的类型。泛型可以用于函数、类、接口等，以提高代码的复用性和灵活性。例如</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 调用时指定具体的类型</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是枚举（enum），作用和使用场景，枚举和常量枚举的区别"><a href="#什么是枚举（enum），作用和使用场景，枚举和常量枚举的区别" class="headerlink" title="什么是枚举（enum），作用和使用场景，枚举和常量枚举的区别"></a>什么是枚举（enum），作用和使用场景，枚举和常量枚举的区别</h2><p>枚举（enum）是一种用于定义一组命名常量的类型，它可以提高代码的可读性和维护性。枚举是一种类型，它允许你定义一组命名常量，枚举中的每个成员都有一个名称和一个值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，定义了一个名为 Color 的枚举，它包含了三个成员：<code>Red</code>、<code>Green</code> 和 <code>Blue</code>。默认情况下，枚举成员的值从 0 开始递增，所以它们的值分别为 0、1 和 2。可以使用枚举成员来访问枚举值，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(color); <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure>

<p>手动分配枚举值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&quot;DOWN&quot;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&quot;RIGHT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量枚举（const enum），它是在编译阶段被完全移除的枚举，不会在生成的 JavaScript 代码中出现，而是在编译阶段被替换为相应的常量值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，定义了一个常量枚举 <code>Color</code>，在编译后的 JavaScript 代码中， color 变量将被直接赋值为 0，而不会有 <code>Color</code> 枚举的存在。</p>
<p>优点：</p>
<ul>
<li>常量枚举可以减少生成的 JavaScript 代码的大小，因为它们在编译时被替换它们的值</li>
<li>它们也可以提高代码的性能，因为在运行时不需要进行枚举的查找</li>
</ul>
<p>枚举和常量枚举：</p>
<ul>
<li><code>枚举</code>可以包含计算得出的值，而常量枚举则在编译阶段被删除，并且不能包含计算得出的值，只能包含常量成员</li>
<li><code>常量枚举</code>在编译后会被删除，而普通枚举会生成真实的对象。</li>
</ul>
<h2 id="介绍-TypeScript-的可选属性、只读属性和类型断言"><a href="#介绍-TypeScript-的可选属性、只读属性和类型断言" class="headerlink" title="介绍 TypeScript 的可选属性、只读属性和类型断言"></a>介绍 TypeScript 的可选属性、只读属性和类型断言</h2><ul>
<li>可选属性，使用 <code>?</code> 来标记一个属性可以存在，也可以不存在。</li>
<li>只读属性，使用 <code>readonly</code> 来标记一个属性只能在声明时赋值，不能在后续的代码中修改。</li>
<li>类型断言，使用 <code>as</code> 关键字来告诉编译器一个变量的类型。<br>使用场景：<ul>
<li>当你不确定一个变量的类型时，可以使用类型断言来告诉编译器。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">len</span>: <span class="built_in">number</span> = (str <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>; <span class="comment">// 类型断言</span></span><br></pre></td></tr></table></figure></li>
<li>当你需要将一个联合类型的值指定为其中的某一个类型时。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = x <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 类型断言</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>类型断言只是一种告诉编译器你认为某个值的类型的方式，但是它并不能真正改变值的类型，如果断言不正确，在运行时将导致错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只读属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b1</span>: <span class="title class_">Book</span> = &#123; <span class="attr">title</span>: <span class="string">&quot;TypeScript&quot;</span> &#125;;</span><br><span class="line">b1.<span class="property">title</span> = <span class="string">&quot;JavaScript&quot;</span>; <span class="comment">// 报错，只读属性不能修改</span></span><br><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">len</span>: <span class="built_in">number</span> = (str <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">length</span>; <span class="comment">// 类型断言</span></span><br></pre></td></tr></table></figure>

<h2 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h2><p>允许一个变量可以是多种类型中的一种，使用 <code>|</code> 来分隔不同的类型。可以让代码更加灵活和可维护，同时也可以提高类型安全性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value 可以是 string 类型或者 number 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: value | <span class="built_in">number</span></span><br></pre></td></tr></table></figure>

<h2 id="交叉类型（Intersection-Types）"><a href="#交叉类型（Intersection-Types）" class="headerlink" title="交叉类型（Intersection Types）"></a>交叉类型（Intersection Types）</h2><p>用于将多个类型合并为一个类型，通过使用 <code>&amp;</code> 符号实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Employee</span> = &#123; <span class="attr">salary</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// PersonEmployee 类型包含了 Person 和 Employee 类型的所有属性，即 name、age 和 salary 属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonEmployee</span> = <span class="title class_">Person</span> &amp; <span class="title class_">Employee</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">employee</span>: <span class="title class_">PersonEmployee</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">salary</span>: <span class="number">5000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接口也可以交叉：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">area</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Colorful</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ColorfulShape 类型包含了 Shape 和 Colorful 接口的所有属性，即 area() 方法和 color 属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ColorfulShape</span> = <span class="title class_">Shape</span> &amp; <span class="title class_">Colorful</span>;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>如果交叉的类型中有同名的属性，那么这些属性的类型必须是兼容的</li>
<li>交叉类型可以创建非常复杂的类型，但也可能导致代码的可读性降低，在使用时要确保代码的意图清晰，避免过度复杂的类型定义</li>
</ul>
<h2 id="索引类型（Index-Types）"><a href="#索引类型（Index-Types）" class="headerlink" title="索引类型（Index Types）"></a>索引类型（Index Types）</h2><p>使用场景：</p>
<ul>
<li>处理动态属性名<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">config</span>: <span class="title class_">Config</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">enableLog</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getConfig</span>(<span class="params"><span class="attr">key</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> config[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>处理 API 响应数据，当从 API 接收到的数据结构不确定时，可以使用索引类型来处理这些数据<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiResponse</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">response</span>: <span class="title class_">ApiResponse</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">salary</span>: <span class="number">5000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>创建可扩展的对象类型（可以动态添加属性的对象类型）<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ExtensibleObject</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">ExtensibleObject</span> = &#123;&#125;;</span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">obj.<span class="property">b</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="const-和-readonly-关键字"><a href="#const-和-readonly-关键字" class="headerlink" title="const 和 readonly 关键字"></a>const 和 readonly 关键字</h2><p>const</p>
<ol>
<li>用于变量声明，const 用于声明一个常量，它的值不能被重新赋值</li>
<li>基本类型和引用类型的区别</li>
</ol>
<ul>
<li>基本类型：const 声明的基本类型变量的值是不可变的，即不能被重新赋值</li>
<li>引用类型：const 声明的引用类型变量的引用是不可变的，即不能被重新赋值，但引用类型的属性或元素可以被修改</li>
</ul>
<p>readonly</p>
<ol>
<li>用于属性声明，readonly 用于声明类的属性或接口的属性为只读属性，即只能在对象初始化时或在构造函数中赋值，之后不能被重新赋值</li>
<li>数组和对象的只读性，当 readonly 用于数组或对象类型时，数组或对象本身的引用可以被重新赋值，但它们的元素或属性不能被修改（如果它们不是本身也被 readonly 修饰）</li>
</ol>
<p>使用场景：</p>
<ul>
<li>const<ul>
<li>当你确定一个变量的值在整个程序执行过程中都不会改变时，使用 const 声明变量。</li>
<li>对于简单的值类型（如数字、字符串、布尔值）和不可变的引用类型（如不可变的对象或数组），使用 const 可以提高代码的可读性和安全性。</li>
</ul>
</li>
<li>readonly<ul>
<li>在类中，当你希望某个属性在对象创建后不能被修改时，使用 readonly 修饰属性。</li>
<li>在接口中，当你希望某个属性在实现该接口的对象中是只读的时，使用 readonly 修饰属性。</li>
<li>对于需要在多个地方共享但不希望被修改的对象或数组，可以使用 readonly 修饰它们的类型，以确保它们的内容不会被意外修改。</li>
</ul>
</li>
</ul>
<h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>尽管any类型提供了灵活性，但由于它会放弃TypeScript的静态类型检查，因此滥用any类型可能会降低代码的健壮性和可维护性。当滥用any类型时，可能会导致以下后果:</p>
<ul>
<li>代码可读性下降</li>
<li>潜在的运行时错误</li>
<li>类型安全受损</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>基本类型<ul>
<li>number，表示数字，包含证书和浮点数</li>
<li>string，表示文本字符串</li>
<li>boolean，表示布尔值，true 和 false</li>
<li>null、undefined</li>
<li>symbol，表示唯一、不可变的值</li>
</ul>
</li>
<li>复合类型<ul>
<li>array，数组</li>
<li>tuple，元组</li>
<li>enum，枚举</li>
</ul>
</li>
<li>对象类型<ul>
<li>object，表示任意对象（除了 number、string、boolean、symbol、null、undefined 之外的类型）</li>
<li>interface，接口，用于描述对象的结构，可重复使用</li>
</ul>
</li>
<li>函数类型<ul>
<li>function，表示函数类型</li>
<li>void，表示函数没有返回值</li>
<li>any，表示任意类型</li>
</ul>
</li>
<li>高级类型<ul>
<li>union types，联合类型，允许一个变量可以是多种类型中的一种</li>
<li>intersection types，交叉类型，用于将多个类型合并为一个类型</li>
</ul>
</li>
</ul>
<h2 id="interface-给-Function-Array-Class（indexable）做声明"><a href="#interface-给-Function-Array-Class（indexable）做声明" class="headerlink" title="interface 给 Function/Array/Class（indexable）做声明"></a>interface 给 Function/Array/Class（indexable）做声明</h2><ul>
<li>函数<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述了一个函数类型，该函数接收两个参数并返回一个数字</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyFunction</span> &#123;</span><br><span class="line">  (<span class="attr">arg1</span>: <span class="built_in">string</span>, <span class="attr">arg2</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myAdd</span>: <span class="title class_">MyFunction</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>数组<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述了一个具有数字索引签名的字符串数组。意味着我们可以通过数字索引来访问数组元素。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">StringArray</span> = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Fred&#x27;</span>];</span><br></pre></td></tr></table></figure></li>
<li>类<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StringDictionary</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myDict</span>: <span class="title class_">StringDictionary</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;30&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://havebear.com/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20TypeScript%20%E7%AF%87/" data-id="cmd8fcqf0002w64g5e1bn5smr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/">__(&#39;next&#39;) &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SCSS/" rel="tag">SCSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="tag">Vue.js 设计与实现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue3/" rel="tag">Vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/" rel="tag">人月神话</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">前端工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95/" rel="tag">备忘录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" rel="tag">开发日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" rel="tag">设计原则和编程技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB/" rel="tag">阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E8%AE%B0/" rel="tag">随记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 19px;">JavaScript</a> <a href="/tags/SCSS/" style="font-size: 10px;">SCSS</a> <a href="/tags/Vue/" style="font-size: 13px;">Vue</a> <a href="/tags/Vue-js-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" style="font-size: 16px;">Vue.js 设计与实现</a> <a href="/tags/Vue3/" style="font-size: 10px;">Vue3</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/" style="font-size: 11px;">人月神话</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 10px;">其他</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 15px;">前端工程化</a> <a href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95/" style="font-size: 11px;">备忘录</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" style="font-size: 10px;">开发日志</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">架构</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">框架</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 12px;">设计原则和编程技巧</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 17px;">设计模式</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 14px;">转载</a> <a href="/tags/%E9%98%85%E8%AF%BB/" style="font-size: 17px;">阅读</a> <a href="/tags/%E9%9A%8F%E8%AE%B0/" style="font-size: 10px;">随记</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 18px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">七月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/18/%E9%9A%8F%E8%AE%B0/2025%E5%B9%B407%E6%9C%8818%E6%97%A5%E9%9A%8F%E8%AE%B0/">2025年07月18日随记</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/">输入URL到渲染全面梳理中-页面渲染篇</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/">输入URL到渲染全面梳理上-网络通信篇</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93/">输入URL到渲染全面梳理下-总结篇</a>
          </li>
        
          <li>
            <a href="/2025/07/18/%E7%A8%8B%E5%BA%8F%E5%91%98/%E9%9D%A2%E8%AF%95/%E6%94%B6%E9%9B%86%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20HTTP%20%E7%AF%87/">收集的面试题 - HTTP 篇</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 havebear<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>